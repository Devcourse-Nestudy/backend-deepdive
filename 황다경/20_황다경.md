데이터베이스 트랜잭션에서 발생할 수 있는 이상 현상을 해결하는 중요한 기법 중 하나는 **락킹 리드(Locking Read)**이다. 특히 **다중 버전 동시성 제어(MVCC)**가 적용된 환경에서도 특정 문제, 예를 들어 **로스트 업데이트(Lost Update)**나 **라이트 스큐(Write Skew)**를 방지하기 위해 개발자가 명시적으로 락킹 리드를 사용하는 경우가 많다. 이번 영상에서는 MySQL을 중심으로 락킹 리드의 동작 방식과 이상 현상 해결 방법을 살펴보고, PostgreSQL과의 차이점도 함께 알아봄

### 1. 로스트 업데이트 방지: `SELECT ... FOR UPDATE`의 활용

MVCC 환경에서 `REPEATABLE READ`와 같은 격리 수준(Isolation Level)에서도 로스트 업데이트가 발생할 수 있다. 예를 들어, 두 트랜잭션이 동시에 같은 계좌의 잔액을 읽고, 각각 다른 금액을 더한 후 다시 쓰는 상황을 생각해보자. 트랜잭션 1이 X를 50으로 읽고, 트랜잭션 2도 X를 50으로 읽은 뒤, 트랜잭션 2가 30을 더해 80으로 쓰고 커밋한다. 이후 트랜잭션 1이 40을 더해 90으로 쓰고 커밋하면, 최종 결과는 90이 되는데, 이는 트랜잭션 2의 업데이트인 80이 사라지는 로스트 업데이트 현상이다.

MySQL에서 이를 해결하기 위해서는 개발자가 쿼리문에 **`FOR UPDATE`** 구문을 명시적으로 추가해야 한다.

- **`SELECT ... FOR UPDATE`의 동작 방식**:

  - 이 구문은 읽기(Read)를 수행하면서 동시에 **쓰기 락(Write Lock), 즉 배타 락(Exclusive Lock)**을 획득하려고 시도한다. 이를 **락킹 리드**라고 부른다.
  - 예를 들어, 트랜잭션 2가 `SELECT balance FROM account WHERE id = X FOR UPDATE`를 실행하면, X에 대한 쓰기 락을 획득하면서 값을 읽는다.
  - 이후 트랜잭션 1이 동일하게 `SELECT balance FROM account WHERE id = X FOR UPDATE`를 시도하면, X에 대한 쓰기 락을 획득하려고 하지만, 이미 트랜잭션 2가 락을 쥐고 있으므로 트랜잭션 1은 **블록(Block)되어 락이 반환될 때까지 기다린다**.
  - 트랜잭션 2가 연산을 마치고 커밋하면, X에 대한 락이 반환되고, 기다리던 트랜잭션 1이 락을 획득하여 진행한다.

- **MySQL 락킹 리드의 중요한 특징**:
  - MySQL에서 락킹 리드(`FOR UPDATE`)는 현재 트랜잭션의 격리 수준(`REPEATABLE READ` 등)과 관계없이 **가장 최근에 커밋된 데이터를 읽는다**.
  - 위 예시에서 트랜잭션 1이 트랜잭션 2의 커밋 이후 X에 대한 락을 획득하고 X를 읽을 때, 트랜잭션 시작 시점의 값(50)이 아닌, 트랜잭션 2에 의해 **최근에 커밋된 값(80)을 읽게 된다**.
  - 이렇게 되면 트랜잭션 1은 80에서 40을 빼 40을 최종적으로 쓰고, 트랜잭션 2는 80을 썼으므로, 최종 결과는 X=40, Y=50으로 로스트 업데이트 없이 올바른 결과가 도출된다.
  - 이처럼 `REPEATABLE READ` 격리 수준만으로는 로스트 업데이트가 해결되지 않으며, 락킹 리드를 명시적으로 사용해야 한다.

### 2. 라이트 스큐 방지: 락킹 리드의 확장 적용

라이트 스큐 또한 `REPEATABLE READ` 격리 수준의 MVCC 환경에서 발생할 수 있는 이상 현상이다. 예를 들어, X와 Y의 값을 더하여 X에 쓰고(트랜잭션 1), 동시에 X와 Y의 값을 더하여 Y에 쓰는(트랜잭션 2) 상황을 생각해보자. 초기 X=10, Y=10인 상태에서 두 트랜잭션 모두 X와 Y를 10으로 읽고, 트랜잭션 1이 X를 20으로, 트랜잭션 2가 Y를 20으로 업데이트하고 각각 커밋하면, 최종 결과는 X=20, Y=20이 된다. 하지만 정상적인 연산이라면 (10+10=20, 10+10=20) 결과는 (X=20, Y=30) 또는 (X=30, Y=20)이 되어야 한다. 이처럼 논리적으로 오류가 있는 상태를 라이트 스큐라고 한다.

라이트 스큐를 해결하기 위해서도 락킹 리드를 사용한다. **관련된 모든 데이터(`X`와 `Y` 모두)**를 읽을 때 **`FOR UPDATE`**를 적용해야 한다.

- **락킹 리드를 통한 라이트 스큐 해결 과정**:
  - 트랜잭션 1이 X를 읽을 때 `SELECT ... FOR UPDATE`를 사용하여 X에 대한 쓰기 락을 획득한다.
  - 트랜잭션 2도 X를 읽을 때 `SELECT ... FOR UPDATE`를 시도하지만, 트랜잭션 1이 X에 대한 락을 쥐고 있으므로 **트랜잭션 2는 블록되어 기다린다**.
  - 트랜잭션 1은 이어서 Y를 읽을 때도 `SELECT ... FOR UPDATE`를 사용하여 Y에 대한 쓰기 락을 획득한다.
  - 트랜잭션 1이 X에 20을 쓰고 커밋하면, X와 Y에 대한 락이 반환된다.
  - 그제야 트랜잭션 2는 X에 대한 락을 획득하고 X 값을 읽을 수 있게 된다. 이때 MySQL의 락킹 리드 특성상 **최근 커밋된 X의 값 20을 읽는다**.
  - 트랜잭션 2는 이어서 Y를 읽을 때 `SELECT ... FOR UPDATE`를 사용하고 Y의 값 10을 읽는다.
  - 트랜잭션 2는 (20+10)인 30을 Y에 쓰고 커밋한다.
  - 결과적으로 X=20, Y=30이 되어 라이트 스큐가 해결된다.

### 3. MySQL 락킹 리드의 두 가지 종류: `FOR UPDATE`와 `FOR SHARE`

MySQL의 락킹 리드에는 두 가지 종류가 있다.

- **`SELECT ... FOR UPDATE`**: 앞서 설명했듯이, **쓰기 락(익스클루시브 락)**을 획득한다.
- **`SELECT ... FOR SHARE`**: **읽기 락(쉐어드 락)**을 획득한다. 쓰기 락은 동시에 하나의 트랜잭션만 가질 수 있지만, 읽기 락은 여러 트랜잭션이 동시에 가질 수 있다. 그러나 읽기 락이 설정된 상태에서는 쓰기 락을 획득할 수 없다.

이 두 가지 락킹 리드 구문은 **개발자가 직접 쿼리문에 작성해야 하는 부분이다**. 이 외에도 MySQL에서는 `CONSISTENT READ`라는 용어도 사용된다.

### 4. PostgreSQL과 MySQL 락킹 리드의 동작 방식 차이

`SELECT ... FOR UPDATE`나 `SELECT ... FOR SHARE`와 같은 락킹 리드 문법은 PostgreSQL을 포함한 다른 RDBMS에서도 존재한다. 그러나 **동작 방식에는 중요한 차이**가 있다.

- **PostgreSQL의 `REPEATABLE READ`와 락킹 리드**:
  - PostgreSQL에서 `REPEATABLE READ` 격리 수준일 때, `FOR UPDATE`로 읽으려는 데이터에 대해 **이미 다른 트랜잭션이 업데이트를 완료하고 커밋한 경우**, 현재 트랜잭션은 락을 기다리다가 락을 획득하더라도 **읽기 작업이 실패하고 롤백(Rollback)된다**.
  - 이는 PostgreSQL의 `REPEATABLE READ`가 **"먼저 커밋한 트랜잭션이 승자(First Committer Wins)"**라는 규칙에 따라 동작하기 때문이다.
  - 앞선 라이트 스큐 예시에서, 트랜잭션 1이 X에 20을 쓰고 커밋한 후 X에 대한 락이 반환된다. 이때 X에 대한 락을 기다리던 트랜잭션 2는 락을 획득하지만, 이미 X가 트랜잭션 1에 의해 업데이트되고 커밋되었으므로, **트랜잭션 2의 X 읽기 시도가 실패하여 트랜잭션 2는 롤백된다**.
  - 결과적으로 트랜잭션 1만 커밋되고 트랜잭션 2는 롤백되므로 최종 데이터는 X=20, Y=10 (트랜잭션 1의 최종 결과)이 된다. 이는 라이트 스큐 문제가 해결된 올바른 결과이지만, 트랜잭션 중 하나는 롤백되어 재시도를 해야 한다는 차이가 있다.
  - 이러한 "먼저 커밋한 트랜잭션이 승자" 규칙은 `FOR UPDATE`뿐만 아니라 `FOR SHARE`에도 동일하게 적용된다.

결론적으로, 락킹 리드를 사용하여 로스트 업데이트나 라이트 스큐를 해결하는 방법 자체는 MySQL과 PostgreSQL 모두에 적용 가능하지만, **`REPEATABLE READ` 격리 수준에서 실제 동작 방식은 다르다**. MySQL은 락 해제 후 최신 커밋 데이터를 읽어 진행시키는 반면, PostgreSQL은 충돌 시 트랜잭션을 롤백시킨다.

### 5. `SERIALIZABLE` 격리 수준을 통한 해결

락킹 리드를 사용하는 방법 외에, 데이터베이스의 **격리 수준을 `SERIALIZABLE`로 올리는 것**으로도 이러한 이상 현상들을 해결할 수 있다. `SERIALIZABLE`은 가장 강력한 격리 수준으로, 모든 이상 현상을 방지한다. 하지만 이 격리 수준에서도 MySQL과 PostgreSQL의 내부 동작 방식은 차이가 있다.

- **MySQL의 `SERIALIZABLE`**:

  - `SERIALIZABLE` 격리 수준이 `REPEATABLE READ`와 유사하게 동작한다.
  - 트랜잭션 내의 모든 일반 `SELECT` 문은 **암묵적으로 `SELECT ... FOR SHARE`처럼 동작한다**. 즉, MySQL이 내부적으로 읽기 락을 획득하여 동시성을 제어한다.
  - 따라서 MySQL의 `SERIALIZABLE` 격리 수준은 MVCC보다는 **락(Lock) 기반으로 동작한다**고 흔히 이야기된다.
  - `FOR UPDATE`(배타 락) 대신 `FOR SHARE`(공유 락)처럼 동작하게 하는 것은 성능 때문이다. 배타 락은 성능 이슈를 유발할 수 있기 때문이다.
  - 하지만 `FOR SHARE` 방식은 `FOR UPDATE` 방식에 비해 **데드락 발생 가능성이 상대적으로 높다**는 단점이 있다.

- **PostgreSQL의 `SERIALIZABLE`**:
  - `SERIALIZABLE` 격리 수준은 **SSI(Serializable Snapshot Isolation)**로 구현되어 있다.
  - SSI는 여전히 MVCC 방식으로 동작하면서도 모든 이상 현상을 막아주는 고급 격리 기법이다.
  - SSI도 대략적으로는 "먼저 커밋한 트랜잭션이 승자" 방식으로 동작하는 것으로 알려져 있다. (다만, SSI의 자세한 동작 방식은 더 깊은 학습이 필요하다.)

---

오늘날 많은 RDBMS가 MVCC 방식으로 동작하지만, 내부적인 구현 디테일은 각 RDBMS마다 조금씩 다르다. `REPEATABLE READ` 격리 수준에서도 발생할 수 있는 로스트 업데이트나 라이트 스큐 같은 이상 현상은 **`SELECT ... FOR UPDATE`와 같은 락킹 리드를 명시적으로 사용하거나, 격리 수준을 `SERIALIZABLE`로 높여 해결할 수 있다**. 특히, 락킹 리드를 사용할 때 MySQL과 PostgreSQL은 **충돌 상황에서 동작 방식이 다르다**는 점을 인지해야 한다. MySQL은 락 해제 후 최신 커밋 데이터를 읽는 반면, PostgreSQL은 트랜잭션을 롤백시킨다. 개발자는 자신이 사용하는 RDBMS의 특성과 동작 방식을 잘 숙지하고 상황에 맞는 트랜잭션 제어 방식을 적용하는 것이 중요하다.
