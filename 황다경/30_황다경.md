B-트리(B-tree)는 데이터베이스 인덱스와 관련된 자료 구조로, 이진 탐색 트리(Binary Search Tree)를 일반화한 트리이다. 이진 탐색 트리와 유사하게 B-트리에서도 키를 기준으로 왼쪽 서브 트리는 해당 키보다 작은 값을, 오른쪽 서브 트리는 큰 값을 가진다. 이러한 특징은 모든 데이터에 동일하게 적용된다.

B-트리가 이진 탐색 트리를 일반화한 형태라고 불리는 이유는 이진 탐색 트리는 부모 노드가 가질 수 있는 자녀 노드의 최대 수가 2개인 반면, B-트리에서는 부모 노드가 **두 개 이상의 자녀 노드를 가질 수 있기 때문**이다. 또한, B-트리에서는 어떤 노드가 자녀 노드를 X개 가졌다면, 그 노드의 키 수는 X-1개를 가진다. 각 노드에는 한 개 이상의 키가 존재하며, 이 키들은 **오름차순으로 정렬되어 저장된다**. 모든 리프 노드는 같은 레벨에 존재한다는 특징도 있다.

B-트리의 동작 방식은 **`m`이라는 파라미터**에 의해 결정된다. `m`은 각 노드가 가질 수 있는 **최대 자녀 노드 수**를 의미하며, B-트리에서 가장 근본이 되는 파라미터이다. `m`이 결정되면 다른 세 가지 파라미터가 자동으로 결정된다:

- **각 노드의 최대 키 수**: `m-1`.
- **각 노드의 최소 자녀 노드 수**: `m`을 2로 나눈 값을 올림한 값.
- **각 노드의 최소 키 수**: 위에서 구한 최소 자녀 노드 수에서 1을 뺀 값. 이 최소 키 수 조건은 데이터 삭제 시 매우 중요한 역할을 한다.

예를 들어, `m`이 3인 3차 B-트리의 경우, 각 노드가 가져야 하는 최소 키 수는 (3을 2로 나눈 값인 1.5를 올림하여 2, 그 다음 1을 뺀) 1개이다.

---

### B-트리 데이터 삭제 방식

B-트리에서 데이터 삭제는 기본적으로 **항상 리프 노드에서 발생한다**. 만약 데이터를 삭제한 후, 해당 노드의 키 수가 **최소 키 수보다 적어지면 트리를 재조정해야 한다**.

**1. 인터널 노드(Internal Node) 데이터 삭제 처리**
삭제하려는 데이터가 인터널 노드에 있는 경우, 해당 데이터를 직접 삭제하지 않고, **리프 노드에 있는 데이터와 위치를 바꾼 뒤 그 위치에서 삭제한다**. 이 때, 어떤 데이터와 위치를 바꿔야 하는지가 중요한데, 삭제하려는 데이터의 **선임자(Predecessor) 또는 후임자(Successor)와 위치를 바꿔야 한다**.

- **선임자**: 트리에서 삭제하려는 데이터보다 작은 값들 중 가장 큰 데이터를 의미한다.
- **후임자**: 트리에서 삭제하려는 데이터보다 큰 값들 중 가장 작은 데이터를 의미한다.

**선임자나 후임자와 위치를 바꿔야 하는 이유**는 그렇게 했을 때 B-트리의 속성을 그대로 만족시킬 수 있기 때문이다. 예를 들어, 어떤 키 `K`를 삭제하고 그 자리에 `K`의 선임자 `P`를 올리면, `P`의 왼쪽 서브 트리는 `P`보다 작은 값을, 오른쪽 서브 트리는 `P`보다 큰 값을 가지게 되어 B-트리의 정렬 특성이 유지된다.

또한, 삭제하려는 데이터의 **선임자나 후임자는 항상 리프 노드에 존재한다**.

- **선임자를 찾는 과정**: 특정 노드 `K`의 선임자를 찾으려면 `K`의 **왼쪽 서브 트리**로 이동하여, 그 서브 트리에서 **가장 큰 값을 가진 노드**를 찾아야 한다. 이는 왼쪽 서브 트리에서 계속해서 오른쪽 자녀 노드로 이동하며 더 이상 오른쪽으로 갈 수 없을 때까지 내려가는 방식으로 찾을 수 있다. 이때 더 이상 오른쪽으로 갈 수 없을 때 도달하는 노드는 B-트리의 특성상 항상 리프 노드가 된다.
- 후임자를 찾는 과정은 선임자와 반대로 생각하면 된다.

따라서, 인터널 노드의 데이터를 삭제하려 할 때, 해당 데이터의 선임자 또는 후임자와 위치를 바꾸면, **삭제될 데이터가 항상 리프 노드로 이동하게 된다**. 이는 결국 B-트리에서의 모든 삭제가 리프 노드에서 발생한다는 초기 전제를 성립시킨다.

**2. 데이터 삭제 후 재조정 (Rebalancing)**
리프 노드에서 데이터를 삭제한 후, 해당 노드의 키 수가 최소 키 수 조건(예: 3차 B-트리에서 1개)을 위반하면 트리를 재조정해야 한다. 재조정에는 크게 세 가지 과정이 있다:

**가. 키 여유가 있는 형제의 지원을 받는 경우**
문제가 생긴 노드를 기준으로 좌우 형제 중 키 수가 여유 있는(최소 키 수보다 많은 키를 가진) 형제의 지원을 받는다.

- **동생(왼쪽 형제)에게 지원 요청**: 보통 왼쪽에 있는 동생에게 먼저 도움을 요청한다. 동생이 여유가 있다면, 동생으로부터 키 하나를 받는다. 이 때 **정렬 순서를 유지**해야 하므로, 부모 노드의 키와 형제의 키를 교환하는 방식으로 이루어진다.

  1.  부모 노드에서 문제가 생긴 노드와 동생 노드 사이에 있는 키를 문제가 생긴 노드로 내린다.
  2.  동생 노드의 가장 큰 키를 부모 노드의 원래 위치로 올린다.
  3.  동생 노드는 해당 키를 삭제하고, 문제가 생긴 노드는 새로운 키를 추가하여 최소 키 수 조건을 만족시킨다.

- **형(오른쪽 형제)에게 지원 요청**: 동생이 여유가 없거나 없는 경우, 형에게 도움을 요청한다. 형이 여유가 있다면, 형으로부터 키 하나를 받는다.
  1.  부모 노드에서 문제가 생긴 노드와 형 노드 사이에 있는 키를 문제가 생긴 노드로 내린다.
  2.  형 노드의 가장 작은 키를 부모 노드의 원래 위치로 올린다.
  3.  형 노드는 해당 키를 삭제하고, 문제가 생긴 노드는 새로운 키를 추가하여 최소 키 수 조건을 만족시킨다.

**나. 형제의 지원이 불가능할 경우 (부모의 지원 + 형제와 합치기)**
좌우 형제 노드 모두 키 수가 최소 키 수만 가지고 있어 여유가 없는 경우에 해당한다. 이 때는 부모 노드의 지원을 받아 형제 노드와 합쳐야 한다. 합칠 때는 보통 **왼쪽으로 합치는 것**을 원칙으로 한다.

1.  부모 노드에서 합쳐지려는 두 형제 노드 사이에 있는 키를 왼쪽 노드(합쳐지는 대상)로 내린다.
2.  문제가 생긴 노드에 남아있는 모든 키를 왼쪽 노드로 옮겨 합친다.
3.  문제가 생긴 노드는 비어있게 되므로 삭제한다.
4.  부모 노드에서는 키가 하나 줄어들었으므로, 남은 키와 자녀 포인터를 조정한다.

이 과정은 데이터를 삽입할 때 발생했던 '승진(Promotion)' 과정의 반대와 유사하다.

**다. 재조정 과정이 부모 노드에 문제 발생시킨 경우**
형제 노드를 합치는 과정에서 부모 노드의 키 수가 최소 키 수 조건보다 적어지는 문제가 발생할 수 있다. 이 경우, **해당 부모 노드 위치에서 다시 1번(형제 지원 요청)부터 재조정을 시작한다**.

- **부모 노드가 루트 노드이고 비어 있게 된 경우**: 루트 노드가 비어있게 되면, 해당 루트 노드를 삭제하고, 직전에 합쳐졌던 노드가 새로운 루트 노드가 된다.
- **부모 노드가 루트 노드이지만 비어 있지 않은 경우**: 루트 노드는 최소 키 수 조건에서 예외이므로, 이 경우 재조정은 해당 위치에서 종료된다.

---

B-트리에서 데이터 삭제는 항상 리프 노드에서 발생한다. 인터널 노드의 데이터를 삭제하려면 해당 데이터의 선임자 또는 후임자와 위치를 바꿔 리프 노드로 옮긴 후 삭제한다. 삭제 후 노드의 키 수가 최소 키 수보다 적어지면, 키 여유가 있는 형제로부터 키를 빌리거나 (부모 노드를 매개로 하여 키를 교환), 형제가 모두 여유가 없으면 부모 노드의 지원을 받아 형제 노드와 합치는 방식으로 재조정을 수행한다. 이 과정이 부모 노드에 문제를 발생시키면 재조정은 부모 노드에서 다시 시작된다.
