## B-트리: 개념, 특징, 그리고 데이터 삽입 방식 이해하기

B-트리는 **DB 인덱스**와 밀접한 관련이 있는 중요한 자료 구조이며, 그 개념과 특징, 그리고 데이터 삽입 방식까지 심도 있게 다룬다.

### B-트리는 왜 탄생했을까? 바이너리 서치 트리와의 비교

과거에 학습했던 **이진 탐색 트리(Binary Search Tree, BST)**를 먼저 복습한다. BST는 다음과 같은 특징을 가진다:

- 모든 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값들만 가진다.
- 모든 노드의 오른쪽 서브 트리는 해당 노드의 값보다 큰 값들만 가진다.
- 예를 들어, 20이라는 값을 가진 노드의 왼쪽 서브 트리는 20보다 작은 값을, 오른쪽 서브 트리는 20보다 큰 값을 가진다.
- 가장 중요한 특징은 **자녀 노드를 최대 2개까지 가질 수 있다**는 점이다. 이것이 '이진(Binary)'이라는 이름이 붙은 이유이다.

그런데 만약 자녀 노드를 3개 이상 가지고 싶다면 어떻게 해야 할까? BST의 아이디어를 확장하여, 부모 노드의 값을 기준으로 좌우로 나누는 방식을 응용할 수 있다.
자녀 노드가 3개라면, 각 자녀 노드가 가질 수 있는 값의 범위를 결정해야 한다. 예를 들어, `K1`과 `K2`라는 두 개의 키가 부모 노드에 있다면:

- 왼쪽 자녀 노드는 `K1`보다 작은 값을 가진다.
- 가운데 자녀 노드는 `K1`보다는 크고 `K2`보다는 작은 값을 가진다.
- 오른쪽 자녀 노드는 `K2`보다 큰 값을 가진다.

이처럼 **하나의 부모 노드에 하나의 값만 저장하는 것이 아니라, 여러 개의 키(`K1`, `K2` 등)를 함께 저장**하고, 이 키들을 **오름차순으로 정렬**하여 저장함으로써 자녀 노드들의 값 범위를 결정하는 방식이 바로 B-트리이다.

**B-트리**는 바이너리 서치 트리와 동작 방식이 매우 유사하면서도, **최대로 가질 수 있는 자녀 노드의 개수를 원하는 만큼 결정해서 쓸 수 있다**는 특징을 가진다. 이 때문에 B-트리는 바이너리 서치 트리를 **일반화한 형태의 트리**라고도 불린다.

### B-트리의 핵심 파라미터

B-트리를 사용할 때 **최대 몇 개의 자녀 노드를 가질 수 있도록 할 것인가**가 가장 중요한 파라미터가 된다. 이 값을 **m**으로 표기하며, **최대 m개의 자녀를 가질 수 있는 B-트리를 'm차 B-트리'라고 부른다**. 예를 들어, 최대 3개의 자녀 노드를 가질 수 있는 B-트리는 3차 B-트리라고 부른다.

이 `m` 값에 따라 다른 파라미터들이 자연스럽게 결정된다:

1.  **각 노드가 가질 수 있는 최대 키의 수**: **`m - 1`개다**. 자녀 노드의 값 범위를 `m`개로 나누기 위해서는 `m-1`개의 키가 필요하기 때문이다. 예를 들어, 3차 B-트리라면 최대 3개의 자녀 노드를 가질 수 있으므로, 각 노드는 `3 - 1 = 2`개의 키를 최대로 가질 수 있다.

2.  **각 노드가 가질 수 있는 최소한의 자녀 노드 수**: **`⌈m / 2⌉`** (m을 2로 나눈 값을 올림한 수)개다.

    - 이 조건은 **루트 노드나 리프 노드에서는 제외**된다.
    - 리프 노드는 자녀 노드가 없으므로 당연히 제외된다.
    - 루트 노드는 트리의 시작점으로서, 처음 데이터가 들어갈 때 이 조건을 만족하지 않을 수 있기 때문에 제외된다.
    - 나머지 내부(Internal) 노드들은 이 조건을 만족해야 한다.
    - 예를 들어, 3차 B-트리라면 `⌈3 / 2⌉ = ⌈1.5⌉ = 2`이므로, 각 노드는 최소 2개의 자녀 노드를 가져야 한다.

3.  **각 노드가 가질 수 있는 최소한의 키 수**: **`⌈m / 2⌉ - 1`**개다. 이는 최소 자녀 노드 수에서 1을 뺀 값과 같다.
    - 이 파라미터 역시 **루트 노드에서는 제외**된다.

참고로, `m`을 기준 파라미터로 잡고 설명하는 것이 가장 명확하다고 보지만, 설명 방식에 따라서는 최대 키의 수, 최소 자녀 노드 수 등을 기준 파라미터로 삼을 수도 있다.

### B-트리 내부 노드의 특징

B-트리의 **내부 노드(Internal Node)**는 중요한 특징을 가진다:

- **만약 어떤 내부 노드의 키의 수가 `x`개라면, 그 노드의 자녀 노드의 수는 언제나 `x + 1`개여야 한다**.
- 예를 들어, 부모 노드의 키가 2개라면 자녀 노드는 3개여야 정상적인 형태이다. 키가 1개라면 자녀 노드는 2개여야 한다.
- 이 규칙을 바탕으로, **몇 차 B-트리인지와 상관없이 B-트리의 내부 노드는 최소한 두 개의 자녀를 항상 가진다**는 결론을 도출할 수 있다. (최소한 하나의 키는 가져야 하기 때문).

### B-트리 데이터 삽입 방식

B-트리에 데이터를 삽입하는 과정은 다음과 같은 두 가지 핵심 원칙을 따른다:

1.  **데이터 추가는 항상 리프 노드에서 발생한다**.
2.  데이터가 추가되었을 때 **노드가 넘치면(Overflow)**, **가운데 키 값(중앙값, Median)을 기준으로 좌우 키들을 분할시키고, 가운데 키는 상위 레벨로 승진(Promote)시킨다**.

여기서 **'노드가 넘친다'**는 것은 하나의 노드에 **`m - 1`개보다 더 많은 수의 키를 저장하고 있는 것**을 의미한다.

이제 3차 B-트리(최대 3개의 자녀 노드, 즉 최대 2개의 키를 가질 수 있는 B-트리)를 예로 들어 데이터 삽입 과정을 자세히 살펴본다.

#### 1. 초기 삽입: 1 추가

- 아무것도 없는 상태이므로, 루트 노드를 만들고 **1**을 추가한다.
- 이 노드는 최대 `m-1`개, 즉 2개의 키를 저장할 수 있는 공간을 가진다.

#### 2. 15 추가

- 1은 루트 노드이자 리프 노드이다.
- 빈 공간이 있으므로, 1이 있는 노드에 **15**를 추가한다. 노드는 ``가 된다.

#### 3. 2 추가 (노드 분할 및 승진 발생)

- 항상 리프 노드에 추가한다. 현재 노드에 **2**를 추가하되, 오름차순으로 정렬하여 저장한다.
- 노드에는 ``가 저장된다.
- **문제 발생: 노드가 넘쳤다!** (최대 2개인데 3개가 됨).
- **가운데 키인 2를 기준으로 분할**한다.
  - **2는 상위 레벨로 승진**한다.
  - **1은 왼쪽 노드로**, **15는 오른쪽 노드로 분할**된다.
- 결과적으로 2가 새로운 루트 노드가 되고, 2의 왼쪽에 `노드, 오른쪽에` 노드가 연결된다. 이때 얇은 막대기처럼 보이는 부분은 자녀 노드를 가리키는 포인터 역할을 한다.

#### 4. 5 추가

- 5를 추가하기 위해 조회한다. 루트 노드(2)에서 5가 2보다 크므로 오른쪽(`` 노드 방향)으로 이동한다.
- 리프 노드 `를 만나므로 여기에 5를 추가한다. 오름차순으로 정렬하여 `가 된다. 노드가 넘치지 않으므로 추가가 완료된다.

#### 5. 30 추가 (노드 분할 및 승진 발생)

- 30을 추가하기 위해 조회한다. 루트 노드(2)에서 30이 2보다 크므로 오른쪽(`` 노드 방향)으로 이동한다.
- 리프 노드 ``를 만나므로 여기에 30을 추가한다.
- 오름차순으로 정렬하여 ``이 된다.
- **문제 발생: 노드가 넘쳤다!** (최대 2개인데 3개가 됨).
- **가운데 키인 15를 기준으로 분할**한다.
  - **15는 상위 레벨(부모 노드)로 승진**한다.
  - **5는 왼쪽 노드로**, **30은 오른쪽 노드로 분할**된다.
- 부모 노드(2)에 빈 공간이 있으므로, 15는 2의 오른쪽 빈 공간으로 승진하여 ``가 된다.
- 15의 왼쪽에는 `노드가, 오른쪽에는` 노드가 연결된다.

#### 6. 90 추가

- 90을 추가하기 위해 조회한다. 루트 노드 `에서 90이 15보다 크므로 오른쪽(` 노드 방향)으로 이동한다.
- 리프 노드 ``을 만나므로 여기에 90을 추가한다.
- 오름차순으로 정렬하여 ``이 된다. 노드가 넘치지 않으므로 추가 완료된다.

#### 7. 20 추가 (두 번의 노드 분할 및 승진 발생)

- 20을 추가하기 위해 조회한다. 루트 노드 `에서 20이 15보다 크므로 오른쪽(` 노드 방향)으로 이동한다.
- 리프 노드 ``을 만나므로 여기에 20을 추가한다.
- 오름차순으로 정렬하여 ``이 된다.
- **문제 발생: 노드가 넘쳤다!** (최대 2개인데 3개가 됨).
- **가운데 키인 30을 기준으로 분할**한다.
  - **30은 상위 레벨로 승진**한다.
  - **20은 왼쪽 노드로**, **90은 오른쪽 노드로 분할**된다.
- 30이 부모 노드 ``로 승진해야 하는데, 부모 노드가 이미 꽉 차 있다 (2개 키).
- **부모 노드 `에 30이 추가되면서 `이 되어 넘치게 된다**.
- **다시 한번 부모 노드의 분할 및 승진이 필요하다!**.
- 부모 노드 ``에서 **가운데 키인 15를 기준으로 분할**한다.
  - **15는 가장 상위 레벨(새로운 루트 노드)로 승진**한다.
  - **2는 왼쪽 노드**로 (기존 2의 왼쪽 자녀들 포함), **30은 오른쪽 노드**로 (기존 30의 왼쪽/오른쪽 자녀들 포함) **분할**된다.
- 결과적으로 15가 새로운 루트 노드가 되고, 15의 왼쪽에 `노드, 오른쪽에` 노드가 연결되는 구조가 된다.

이후 7, 9, 8, 10, 50, 70, 60, 40 등의 추가 과정에서도 유사하게 노드 조회, 리프 노드에 삽입, 노드 오버플로우 시 분할 및 중앙값 승진, 부모 노드 오버플로우 시 재귀적으로 분할 및 승진 등의 과정이 반복된다.

### B-트리의 중요한 특징

B-트리의 가장 큰 특징은 **모든 리프 노드들이 항상 같은 레벨에 있다**는 점이다.

- 이러한 특징 때문에 B-트리는 **밸런스드 트리(Balanced Tree)**라고 불린다.
- 이진 탐색 트리와 달리, B-트리는 최악의 경우에도 특정 경로로만 노드가 추가되어 한쪽으로 치우치는 현상(Skewed Tree)이 발생하지 않는다.
- 따라서 B-트리에서 **검색(조회)을 할 때, 평균적인 경우나 최악의 경우 모두 시간 복잡도가 `O(log n)`으로 일정하다**. 이는 데이터를 조회할 때 항상 일정한 성능을 보장한다는 큰 장점이 된다.
