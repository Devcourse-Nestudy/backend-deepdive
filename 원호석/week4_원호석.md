# Week4 

## 1. B-Tree

B-Tree(Balanced Tree)는 균형 이진 트리의 일종으로, 
주로 **데이터베이스와 파일 시스템**에서 인덱스를 구현할 때 사용된다. 
특히, **디스크 I/O 성능을 극대화**하고 **대용량 데이터를 효율적으로 처리**할 수 있도록 설계되어 있다.


## 2. B-Tree의 특징

- 모든 리프 노드는 동일한 깊이를 가진다. -> 삽입, 삭제 발생시 노드 위치를 재조정하여 깊이를 동일하게 유지
- 노드의 키는 정렬되어 있으며, 자식 노드도 그 순서를 따른다.
- 하나의 노드는 다수의 키와 포인터를 가질 수 있다 (m-차 B-Tree는 최대 m개의 자식을 가짐).
- 디스크 접근을 최소화하기 위해 설계되었으며, **디스크 블록 크기에 최적화**된다.

### B+ Tree
- B Tree의 변형으로, 대다수의 dbms가 사용하는 것은 사실 이것이다.
- 값에 대한 정보는 리프 노드에만 저장하고, 내부 노드에는 키와 자식 노드에 대한 포인터만 저장한다.
- 리프 노드에는 값이 liked list 형태로 저장된다.
[img.png](B+-Tree.png)

## 3. B-Tree의 연산

### 검색

- 루트 노드부터 시작해, 이진 검색을 통해 하위 노드로 이동.
- 시간복잡도: O(logₙ N)

### 삽입 

- 리프 노드에 새로운 키 삽입.
- 노드가 가득 차면 분할 발생 → 부모 노드로 전파 → 트리 균형 유지.

### 삭제

- 키를 제거하고 하위 노드에서 재조정.
- 노드의 키 수가 최소보다 적어지면 병합 또는 차용.

---



## 4. B-Tree의 I/O 최적화

### DB와 메모리 구조

```
[ 사용자 요청 (SQL 쿼리) ]
            │
            ▼
[ DBMS의 버퍼 풀 (메인 메모리, RAM) ]
            │
      ┌─────┴─────┐
      ▼           ▼
[B-Tree 인덱스] [실제 데이터 페이지]
            │
            ▼
[ 보조 기억장치 (디스크, SSD/HDD) ]
```
- 사용자: SQL 요청
- 메모리: 자주 접근되는 노드를 캐시 (버퍼 풀)
- B-Tree: 인덱스 탐색 수행
- 디스크: 전체 데이터와 트리 구조 저장

### 디스크 접근 횟수 최소화
디스크에 접근하는 것은 메모리에 접근하는 것보다 훨씬 느리므로, 디스크에 적게 접근할수록 성능이 향상된다.

* 노드당 다수의 키를 저장 → 트리 높이 감소 → 디스크 접근 최소화.

* 컴퓨터가 디스크에서 데이터를 읽을 때, 무조건 디스크 블록의 크기 만큼 끊어 읽는다. 
-> 노드 크기의 크기를 이와 동일하게 설정하여 디스크 접근 최소화 (일반적인 디스크 블록: 4KB → 노드 크기도 동일하게 설정하여 1 I/O에 100~200개의 키 검색 가능)

---

## 5. SQL 쿼리 실행 시 B-Tree 내부 연산

### SELECT

```sql
SELECT * FROM users WHERE id = 1000;
```

1. 루트 노드 로딩
2. 이진 탐색 수행
3. 자식 노드 탐색 → 리프 노드 도달
4. 키 위치 확인 → 데이터 포인터 확인
5. 데이터 페이지 디스크에서 로딩

### INSERT

```sql
INSERT INTO users (id, name) VALUES (1050, 'Alice');
```

1. 삽입 위치 탐색
2. 리프 노드에 키 삽입
3. 노드 분할 발생 시 부모 갱신

### DELETE

```sql
DELETE FROM users WHERE id = 1050;
```

1. 삭제할 키 탐색
2. 리프 노드에서 삭제
3. 병합 또는 차용으로 균형 유지

---

## 9. Reference
- https://planetscale.com/blog/btrees-and-database-indexes