# 데이터베이스 트랜잭션: 격리 수준과 이상 현상 이해하기

데이터베이스에서 여러 트랜잭션이 동시에 실행될 때 예상치 못한 결과가 발생할 수 있다. 이러한 현상을 '이상 현상(Anomalies)'이라 부르며, 데이터의 일관성을 해치고 예상과 다른 결과를 초래할 수 있다. 트랜잭션 격리 수준(Isolation Level)은 이러한 이상 현상들을 얼마나 허용할지 결정하는 메커니즘이다. 

## 트랜잭션 동시 실행 시 발생 가능한 이상 현상

SQL 표준에서는 동시성 제어와 관련하여 세 가지 주요 이상 현상을 정의한다.

### 1. 더티 리드 (Dirty Read)

**더티 리드**는 **커밋되지 않은 다른 트랜잭션의 변경 내용을 읽는 현상**을 의미한다. 트랜잭션 1이 X와 Y를 더하는 작업을 수행하고, 트랜잭션 2가 Y를 변경하는 작업을 수행하는 상황을 예로 들어보자.

*   데이터베이스에 X=10, Y=20이 있다.
*   트랜잭션 1이 시작하여 X를 읽어 10을 가져온다.
*   이때 트랜잭션 2가 시작하여 Y의 값을 70으로 변경한다.
*   트랜잭션 1은 이 변경된 Y 값 70을 읽는다.
*   트랜잭션 1은 X(10)와 Y(70)를 더하여 X에 80을 쓴 후 커밋한다.
*   이후 트랜잭션 2가 어떤 문제로 인해 롤백된다. 롤백은 아무 일도 없었던 것처럼 되돌리는 것이므로 Y는 원래 값인 20으로 돌아간다.

이 상황에서 최종적으로 X는 80이 된다. 그러나 X=80은 트랜잭션 2가 변경했지만 결국 롤백되어 **유효하지 않게 된 Y의 값(70)을 읽어 만들어진 결과**이다. 이는 정상적이지 않은 데이터이며, 이러한 현상을 **더티 리드**라고 한다.

### 2. 논-리피터블 리드 (Non-Repeatable Read / Fuzzy Read)

**논-리피터블 리드**는 **하나의 트랜잭션 안에서 같은 데이터를 두 번 읽었을 때 값이 달라지는 현상**이다. 이는 트랜잭션의 격리 속성(Isolation)이 의미하는 "마치 혼자 실행되는 것처럼 동작해야 한다"는 원칙에 위배된다.

*   데이터베이스에 X=10이 있다.
*   트랜잭션 1이 시작하여 X를 읽어 10을 가져온다.
*   이때 트랜잭션 2가 시작하여 X의 값을 40 더해 50으로 변경하고 커밋한다.
*   트랜잭션 1이 다시 X를 읽으면 50을 가져온다.
*   트랜잭션 1이 커밋한다.

트랜잭션 1은 X를 두 번 읽었는데, 처음에는 10을 읽고 다음에는 50을 읽어 **서로 다른 값**을 가져왔다. 이는 이상 현상이며, **퍼지 리드(Fuzzy Read)**라고 불리기도 한다.

### 3. 팬텀 리드 (Phantom Read)

**팬텀 리드**는 **동일한 조건으로 두 번 쿼리했을 때 첫 번째 쿼리에서는 보이지 않았던 새로운 레코드(튜플)가 두 번째 쿼리에서 나타나는 현상**을 의미한다.

*   데이터베이스에 V 값이 10인 튜플 T1이 있다 (T2는 V 값이 50이다).
*   트랜잭션 1이 시작하여 V 값이 10인 튜플을 읽는다. 현재 T1만 해당하므로 T1을 읽어온다.
*   이때 트랜잭션 2가 시작하여 튜플 T2의 V 값을 10으로 변경하고 커밋한다.
*   트랜잭션 1이 다시 V 값이 10인 튜플을 읽는다. 트랜잭션 2의 변경으로 T2의 V 값도 10이 되었으므로 T1과 T2 둘 다 읽어온다.
*   트랜잭션 1이 커밋한다.

트랜잭션 1은 동일한 조건으로 두 번 읽었지만, 첫 번째는 T1만, 두 번째는 T1과 T2를 읽어 **다른 결과**를 가져왔다. 이는 어떤 데이터가 갑자기 '생긴 것'과 같은 효과를 주므로 **팬텀 리드**라고 한다. 새로운 튜플을 삽입하는 경우에도 팬텀 리드가 발생할 수 있다.

## 트랜잭션 격리 수준 (SQL 표준)

이러한 이상 현상들은 데이터 불일치를 발생시키므로 발생하지 않는 것이 좋지만, 모든 이상 현상을 막으려면 동시 처리 가능한 트랜잭션 수가 줄어들어 데이터베이스의 전체 처리량(Throughput)이 감소하고 성능이 저하된다. 따라서 일부 이상 현상을 허용하면서 성능과 데이터 일관성 사이에서 트레이드오프(Trade-off)를 할 수 있도록 여러 격리 수준이 만들어졌다.

SQL 표준은 다음 네 가지 격리 수준을 정의한다.

1.  **리드 언커미티드 (READ UNCOMMITTED)**
    *   **더티 리드, 논-리피터블 리드, 팬텀 리드 세 가지 현상을 모두 허용한다**.
    *   가장 자유로운 격리 수준이지만, 이상 현상에 가장 취약하다.
    *   동시성이 가장 높아 전체 처리량은 가장 높다.

2.  **리드 커미티드 (READ COMMITTED)**
    *   **커밋된 데이터만 읽기 때문에 더티 리드는 허용하지 않는다**.
    *   논-리피터블 리드와 팬텀 리드는 허용한다.
    *   SQL 표준에서 정의하는 격리 수준 중 하나이며, 많은 상업용 DBMS에서 기본 격리 수준으로 사용된다.

3.  **리피터블 리드 (REPEATABLE READ)**
    *   **더티 리드와 논-리피터블 리드를 허용하지 않는다**.
    *   팬텀 리드는 여전히 허용한다.

4.  **시리얼라이저블 (SERIALIZABLE)**
    *   **더티 리드, 논-리피터블 리드, 팬텀 리드 세 가지 이상 현상을 모두 허용하지 않는다**.
    *   사실상 모든 이상 현상이 발생하지 않는 가장 엄격한 격리 수준을 의미한다.
    *   격리 수준이 엄격해질수록 허용하지 않는 현상들이 늘어나는 특징을 지닌다.

결론적으로, 애플리케이션 개발자는 이 격리 수준을 통해 데이터베이스의 전체 처리량과 데이터의 일관성 사이에서 적절한 균형을 선택할 수 있다.

## SQL 표준 격리 수준에 대한 비판과 추가적인 이상 현상

1995년에 발표된 한 논문은 SQL 표준에서 정의한 격리 수준에 대해 비판을 제기했다.

주요 비판 내용은 다음과 같다:
*   세 가지 이상 현상(더티 리드, 논-리피터블 리드, 팬텀 리드)에 대한 정의가 모호하다.
*   세 가지 외에도 여러 가지 이상 현상이 더 존재한다.
*   상업용 DBMS에서 실제로 사용하는 방법을 반영하여 격리 수준을 구분하지 않았다.

이 논문에서 추가적으로 언급하는 이상 현상들을 살펴보자.

### 1. 더티 라이트 (Dirty Write)

**더티 라이트**는 **커밋되지 않은 데이터를 다른 트랜잭션이 덮어쓰는 현상**을 의미한다. 만약 덮어쓴 트랜잭션이 롤백될 경우, 기존의 커밋된 데이터마저 사라질 수 있다.

*   데이터베이스에 X=0이 있다.
*   트랜잭션 1이 X를 10으로 변경한다.
*   이어서 트랜잭션 2가 X를 100으로 변경한다.
*   트랜잭션 1이 롤백한다. 롤백은 이전 상태로 되돌리는 것이므로 X는 0이 되어야 한다.
*   만약 트랜잭션 1이 X를 0으로 되돌리면, 트랜잭션 2가 X를 100으로 변경했던 내용이 사라진다.

이 상황에서 트랜잭션 2가 커밋까지 했더라도, 트랜잭션 1의 롤백으로 인해 X의 값이 사라지거나 잘못된 값으로 되돌아갈 수 있다. 이 논문은 **더티 라이트를 모든 격리 수준에서 허용해서는 안 된다**고 주장한다. 이는 롤백 시의 정상적인 복구가 매우 중요하기 때문이다.

### 2. 로스트 업데이트 (Lost Update)

**로스트 업데이트**는 **두 트랜잭션이 동일한 데이터를 읽고 각자 변경하여 썼을 때, 나중에 커밋한 트랜잭션의 변경 내용이 다른 트랜잭션의 변경 내용에 의해 덮어씌워져 유실되는 현상**을 의미한다.

*   데이터베이스에 X=50이 있다.
*   트랜잭션 1이 시작하여 X를 읽어 50을 가져온다.
*   이어서 트랜잭션 2도 시작하여 X를 읽어 50을 가져온다.
*   트랜잭션 2는 X에 150을 더해 200으로 변경하고 커밋한다.
*   트랜잭션 1은 이전에 읽었던 50에 50을 더해 100으로 변경하고 커밋한다.

결과적으로 데이터베이스의 X는 100이 된다. 트랜잭션 2가 변경한 200이라는 값은 트랜잭션 1에 의해 덮어씌워져 **사라져 버린 것**이다. 이는 매우 심각한 현상으로, 계좌 이체와 같은 시나리오에서 치명적일 수 있다.

### 3. 더티 리드의 확장된 개념 (P4 anomaly)

이 논문은 기존의 더티 리드가 롤백이 발생했을 때만 문제가 된다고 설명하지만, **롤백이 발생하지 않아도 더티 리드 현상이 일어날 수 있다**고 주장한다. 이는 **데이터의 불일치한 읽기**를 의미한다.

*   X와 Y 계좌가 각각 50씩 있고, 총 합은 100으로 항상 일관성 있게 유지되어야 한다.
*   트랜잭션 1이 X에서 Y로 40을 이체하는 트랜잭션이다.
*   트랜잭션 2가 X와 Y를 각각 읽는 트랜잭션이다.
*   트랜잭션 1이 X를 읽어 50을 확인하고, X에서 40을 빼 10으로 변경한다.
*   이 타이밍에 트랜잭션 2가 X를 읽으면 10을 읽고, Y를 읽으면 50을 읽는다. 트랜잭션 2는 커밋한다.
*   트랜잭션 1이 이어서 Y에 40을 더해 90으로 변경하고 커밋한다.

최종적으로 X는 10, Y는 90이 되어 합계는 100으로 일관성을 유지한다. 그러나 트랜잭션 2는 X를 10, Y를 50으로 읽어 **합계 60이라는 불일치한 데이터를 읽게 된 것**이다. 트랜잭션 1이 롤백되지 않았음에도 트랜잭션 2는 불일치한 데이터를 읽었으며, 이 또한 **더티 리드의 확장된 개념**으로 봐야 한다고 논문은 주장한다.

### 4. 리드 스큐 (Read Skew / P1 anomaly)

**리드 스큐**는 **서로 관련 있는 여러 데이터를 읽을 때, 트랜잭션 중간에 다른 트랜잭션에 의해 일부 데이터가 변경되어 읽는 값들 간에 불일치가 발생하는 현상**이다. 이는 논-리피터블 리드와 유사한 형태를 띤다.

*   X와 Y 계좌가 각각 50씩 있고, 총 합은 100으로 항상 일관성 있게 유지되어야 한다.
*   트랜잭션 1이 X에서 Y로 40을 이체하는 트랜잭션이고, 트랜잭션 2는 X와 Y를 읽는 트랜잭션이다.
*   트랜잭션 2가 먼저 X를 읽어 50을 가져온다.
*   이어서 트랜잭션 1이 X를 10으로 변경하고 Y를 90으로 변경한 후 커밋한다.
*   트랜잭션 2가 이어서 Y를 읽으면 변경된 값인 90을 가져온다.

트랜잭션 2는 X를 50으로, Y를 90으로 읽어 **합계 140이라는 불일치한 데이터**를 읽게 된다. 이는 **리드 스큐**라고 불리는 이상 현상이다.

### 5. 라이트 스큐 (Write Skew / P2 anomaly)

**라이트 스큐**는 **두 트랜잭션이 서로 다른 데이터를 읽고 각자 다른 데이터를 변경하여 썼을 때, 최종적으로 데이터베이스의 일관성 제약 조건(Integrity Constraint)을 위반하게 되는 현상**을 의미한다.

*   X와 Y 계좌가 각각 50씩 있고, X와 Y의 합이 항상 0 이상이어야 한다는 제약 조건이 있다 (X+Y >= 0).
*   트랜잭션 1은 X에서 80을 인출하고, 트랜잭션 2는 Y에서 90을 인출하는 트랜잭션이다.
*   트랜잭션 1이 X와 Y를 읽어 각각 50을 확인하고 합계 100을 확인한다.
*   이 타이밍에 트랜잭션 2도 X와 Y를 읽어 각각 50을 확인하고 합계 100을 확인한다.
*   트랜잭션 1이 X에서 80을 인출하여 X를 -30으로 변경한다.
*   트랜잭션 2가 Y에서 90을 인출하여 Y를 -40으로 변경한다.
*   트랜잭션 1과 트랜잭션 2가 모두 커밋한다.

결과적으로 X는 -30, Y는 -40이 되어 두 값의 합은 -70이 된다. 이는 **X+Y >= 0이라는 제약 조건을 위반**하는 결과이며, **라이트 스큐**라고 불린다. 만약 DBMS가 시리얼라이저블하게 동작했다면 커밋 시점에 이러한 제약 조건 위반이 감지되어 롤백되었을 것이다.

### 6. 팬텀 리드의 확장된 개념 (A5A anomaly)

이 논문은 팬텀 리드의 개념 또한 더 넓은 개념으로 사용해야 한다고 주장한다. 즉, **같은 조건을 두 번 읽는 경우가 아니라 할지라도, 서로 연관된 데이터가 있는 경우 중간에 어떤 데이터가 추가되어 이상 현상이 발생하면 이 또한 팬텀 리드로 봐야 한다**는 것이다.

*   V 값이 7인 튜플 하나(T1)와, V 값이 10보다 큰 튜플의 개수를 저장하는 카운트 데이터가 있다 (현재 카운트는 0).
*   트랜잭션 1은 V 값이 10보다 큰 튜플을 읽고 이어서 카운트를 읽는 트랜잭션이다.
*   트랜잭션 2는 V 값이 15인 튜플을 추가하고 카운트를 1 증가시키는 트랜잭션이다.
*   트랜잭션 1이 시작하여 V 값이 10보다 큰 튜플을 읽는다. 현재 없으므로 아무것도 읽지 않는다.
*   이때 트랜잭션 2가 시작하여 V 값이 15인 튜플 T2를 삽입하고, 카운트 값을 1로 증가시킨 후 커밋한다.
*   이어서 트랜잭션 1이 카운트를 읽으면 1이라는 값을 읽고 커밋한다.

트랜잭션 1은 처음 V 값이 10보다 큰 튜플을 읽었을 때는 없었지만, 그 뒤에 해당 조건에 해당하는 튜플의 수를 카운트하는 데이터를 읽었을 때는 1이라는 값을 가져왔다. 이는 **데이터 불일치**이며, 이 논문은 이 현상 또한 **팬텀 리드의 확장된 개념**으로 봐야 한다고 주장한다.

## 스냅샷 격리 (Snapshot Isolation)

상업용 DBMS의 현실을 반영하여 제안된 격리 수준 중 하나가 바로 **스냅샷 격리**이다. 이는 특정 이상 현상을 허용하는지에 따라 정의되는 SQL 표준 격리 수준과 달리, **동시성 제어(Concurrency Control)가 어떻게 구현되는지에 기반하여 정의된 격리 수준**이다. 즉, 스냅샷 격리는 **멀티 버전 동시성 제어(MVCC: Multi-Version Concurrency Control)의 한 종류**이다.

스냅샷 격리의 핵심 개념은 다음과 같다:
*   **트랜잭션은 시작 시점의 데이터베이스 스냅샷(Snapshot)을 기준으로 데이터를 읽는다.**
    *   스냅샷은 특정 시점의 데이터베이스 형상을 의미한다.
    *   트랜잭션 시작 시점의 스냅샷을 기준으로 데이터를 읽기 때문에, 해당 트랜잭션이 실행되는 동안 다른 트랜잭션이 커밋하여 데이터를 변경하더라도, 현재 트랜잭션은 **자신이 시작했을 때의 구 버전 데이터를 읽는다**.
*   **쓰기 작업은 데이터베이스에 바로 적용되지 않고, 해당 트랜잭션의 스냅샷에 기록된다.**
    *   트랜잭션이 커밋할 때 이 변경 사항이 실제 데이터베이스에 적용된다.
*   **첫 번째 커밋이 승리한다 (First Committer Wins).**
    *   동일한 데이터에 대해 여러 트랜잭션이 쓰기 작업을 시도할 때 (라이트-라이트 충돌), **가장 먼저 커밋하는 트랜잭션의 변경 내용만 인정**된다.
    *   이후에 커밋하려는 트랜잭션은 롤백(abort) 처리된다. 이 메커니즘은 **로스트 업데이트 현상을 방지**한다.

예를 들어 X와 Y 계좌가 각각 50씩 있는 상황에서, 트랜잭션 1은 X에서 Y로 40을 이체하고, 트랜잭션 2는 Y에 100을 입금하는 상황을 스냅샷 격리로 살펴보자.

*   트랜잭션 1이 시작하여 X를 읽어 50을 가져온다 (트랜잭션 1의 시작 시점 스냅샷에 X=50 기록).
*   트랜잭션 1은 X에 10을 쓴다 (이것은 트랜잭션 1의 스냅샷에만 적용된다).
*   이때 트랜잭션 2가 시작하여 Y를 읽어 50을 가져온다 (트랜잭션 2의 시작 시점 스냅샷에 Y=50 기록).
*   트랜잭션 2는 Y에 100을 더해 150을 쓴다 (이것은 트랜잭션 2의 스냅샷에만 적용된다).
*   **트랜잭션 2가 커밋한다.** 이제 Y는 150으로 데이터베이스에 반영된다.
*   이어서 트랜잭션 1이 실행되어 Y에 40을 더해야 하므로 Y를 읽는다.
*   스냅샷 격리로 동작하기 때문에 트랜잭션 1은 **자신이 시작한 시점의 Y 값인 50을 읽는다** (150이 아니라).
*   트랜잭션 1은 50에 40을 더해 Y에 90을 쓴다 (이것은 트랜잭션 1의 스냅샷에만 적용된다).
*   **트랜잭션 1이 커밋하려 한다.** 트랜잭션 1과 트랜잭션 2는 Y라는 같은 데이터에 대해 쓰기 작업을 했다.
*   스냅샷 격리에서는 **먼저 커밋한 트랜잭션 2가 승리하므로, 나중에 커밋하려는 트랜잭션 1은 롤백된다**.

이러한 스냅샷 격리 방식은 라이트 스큐(Write Skew) 현상을 허용하지만 [내부적으로는 허용하는 것으로 이해, 소스에 명시적으로 언급되지 않음], 로스트 업데이트를 방지하며, 많은 상업용 DBMS에서 구현되어 사용되고 있다.

## 실제 RDBMS의 격리 수준 구현

실제로 MySQL, Oracle, SQL Server, PostgreSQL 등 주요 RDBMS는 SQL 표준에 기반하여 격리 수준을 정의하지만, **각 DBMS마다 제공하는 격리 수준의 종류가 다르며, 심지어 같은 이름의 격리 수준이라도 동작 방식에 약간의 차이가 있을 수 있다**.

*   **MySQL (InnoDB 엔진)**: SQL 표준과 동일하게 **리드 언커미티드, 리드 커미티드, 리피터블 리드, 시리얼라이저블** 네 가지 격리 수준을 제공하며, SQL 표준의 세 가지 이상 현상에 기반하여 설명한다.
*   **Oracle DB**: 리드 언커미티드 레벨은 제공하지 않으며, 주로 **리드 커미티드와 시리얼라이저블**을 사용한다. 오라클의 시리얼라이저블 격리 수준은 실제로는 위에서 설명한 **스냅샷 격리** 방식으로 동작한다.
*   **SQL Server**: 5가지 격리 수준을 정의하며, **스냅샷 격리**를 포함한다. 역시 SQL 표준의 세 가지 이상 현상을 위주로 설명한다.
*   **PostgreSQL**: SQL 표준과 동일하게 네 가지 격리 수준을 제공한다. PostgreSQL의 **리피터블 리드** 격리 수준은 **스냅샷 격리** 방식으로 동작한다. 또한, SQL 표준 외의 다른 이상 현상들도 문서에 표기하여 설명한다.

## 실무 적용을 위한 조언

개발자들은 사용하는 RDBMS의 문서를 통해 해당 DBMS가 제공하는 격리 수준과 각 격리 수준의 동작 방식을 정확히 파악해야 한다. 대부분의 RDBMS는 기본(Default) 격리 수준을 제공하며, 이를 그대로 사용해도 큰 문제가 없는 경우가 많다. 그러나 성능 튜닝이 필요하거나 예상치 못한 이상 현상이 발생했을 때를 대비하여 각 격리 수준의 특징과 동작 방식을 잘 알아두는 것이 중요하다.

SQL 표준에서 정의한 세 가지 이상 현상 외에 다양한 이상 현상들을 미리 이해하고 있다면:
*   트랜잭션을 설계할 때 이상 현상이 발생하는 것을 미리 방지할 수 있다.
*   실제 서비스에서 문제가 발생했을 때, 문제의 원인을 파악하는 데 훨씬 더 도움이 될 수 있다.

데이터베이스의 일관성과 시스템의 처리량 사이에서 최적의 균형을 찾는 것은 데이터베이스 설계 및 애플리케이션 개발에서 매우 중요한 과제이다.

----

| 아이솔레이션 레벨 | 더티 리드 | 논 리피터블 리드 | 팬텀 리드 (SQL 표준) | 더티 라이트 | 로스트 업데이트 | 리드 스큐 | 와이트 스큐 |
| :---------------- | :--------- | :----------------- | :-------------------- | :----------- | :------------ | :---------- | :---------- |
| **Read Uncommitted** | o          | o                  | o                     | -          | -             | -             | -             |
| **Read Committed** | x          | o                  | o                     | -        | -             | -             | -             |
| **Repeatable Read** | x          | x                  | o                     | -           | -             | -             | -             |
| **Serializable** | x          | x                  | x                     | x           | x            | x            | x            |
| **스냅샷 아이솔레이션 (Snapshot Isolation)** | x          | x                  | o                    | x            | x             | x             | -             |
