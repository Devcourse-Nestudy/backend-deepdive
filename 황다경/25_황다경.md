## 인덱스 핵심

인덱스는 데이터베이스의 성능을 향상시키는 데 매우 중요한 요소이다.

**1. 데이터베이스 인덱스란 무엇인가?**
데이터베이스 인덱스는 특정 조건을 만족하는 튜플(데이터 레코드)을 빠르게 조회하기 위해 사용되는 특별한 데이터 구조이다. 또한 상황에 따라 데이터를 빠르게 정렬하거나 그룹핑하는 데에도 활용된다. 쉽게 말해, 책의 목차나 찾아보기와 같아서, 원하는 정보를 빠르게 찾을 수 있도록 돕는 역할을 한다.

**2. 인덱스를 사용하는 이유**
인덱스가 없는 경우, 데이터베이스는 쿼리 조건을 만족하는 데이터를 찾기 위해 테이블의 모든 데이터를 하나씩 확인해야 한다. 이를 **풀스캔(Full Scan)** 또는 테이블 스캔(Table Scan)이라고 하며, 데이터가 N개 있을 때 시간 복잡도는 **O(N)**이다.
반면, 인덱스가 걸려 있다면 데이터를 훨씬 더 빠르게 찾을 수 있다. 특히 B-트리(B-tree) 기반 인덱스의 경우 시간 복잡도는 **O(log N)**으로, 데이터 양이 많아질수록 풀스캔보다 월등히 빠르다. 이로 인해 `SELECT` 문은 물론, `WHERE` 절을 사용하는 `DELETE`, `UPDATE` 쿼리나 조인(JOIN) 쿼리의 성능도 향상된다.

**3. 인덱스의 동작 방식 (B-트리 기반)**
대부분의 RDBMS에서 인덱스는 B-트리 기반으로 구현된다. B-트리 인덱스는 다음과 같은 특징을 가진다.

- **정렬된 값 저장**: 인덱스가 생성된 애트리뷰트(컬럼)의 값들을 **정렬된 형태로 저장**한다. 가장 작은 값부터 차례대로 저장된다.
- **포인터**: 실제 데이터가 저장된 테이블의 튜플을 가리키는 **포인터** 정보를 함께 가지고 있다. 이 포인터는 인덱스 데이터와 실제 튜플을 연결하는 역할을 한다.

쿼리가 실행될 때 인덱스는 다음과 같이 동작한다:

1.  **바이너리 서치**: `WHERE a = 9`와 같은 조건으로 데이터를 찾을 때, 인덱스에 저장된 정렬된 값을 기반으로 **바이너리 서치(이진 탐색)**를 수행한다. 이를 통해 탐색 범위를 빠르게 줄여나간다.
2.  **튜플 접근**: 조건에 맞는 값을 찾으면, 해당 값에 연결된 포인터를 사용하여 실제 테이블의 튜플로 직접 이동하여 데이터를 가져온다.

하지만 인덱스가 특정 애트리뷰트(예: A)에만 걸려있는데 쿼리 조건이 `WHERE A = 7 AND B = 95`처럼 다른 애트리뷰트(B)를 함께 포함하는 `AND` 조건이라면, A에 대해서는 빠르게 찾지만, 해당 A 값을 가진 튜플들 중에서 B 조건을 만족하는지를 확인하기 위해 **실제 튜플까지 찾아가서 B 값을 하나하나 비교**해야 한다. 만약 A 조건을 만족하는 튜플이 수천, 수만 개라면 이는 비효율적일 수 있다.

**4. 인덱스 생성 방법 및 종류**
인덱스는 테이블을 생성할 때 함께 만들 수도 있고, 이미 존재하는 테이블에 추가할 수도 있다.

- **기존 테이블에 인덱스 추가 (MySQL 기준)**:

  - **일반 인덱스 (중복 허용)**:
    `CREATE INDEX [인덱스_이름] ON [테이블_이름] ([애트리뷰트_이름]);`
    예시: `CREATE INDEX idx_player_name ON player (name);`
  - **유니크 인덱스 (중복 불허용)**:
    `CREATE UNIQUE INDEX [인덱스_이름] ON [테이블_이름] ([애트리뷰트_이름], ...);`
    예시: `CREATE UNIQUE INDEX udx_player_team_backnumber ON player (team_id, back_number);`

- **테이블 생성 시 인덱스 추가**:
  `CREATE TABLE [테이블_이름] ( [애트리뷰트_이름] [데이터_타입], ..., INDEX [인덱스_이름] ([애트리뷰트_이름]), UNIQUE INDEX [인덱스_이름] ([애트리뷰트_이름], ...) );`
  테이블 생성 시 인덱스 이름은 생략할 수도 있다.

- **프라이머리 키(Primary Key) 인덱스**: 대부분의 RDBMS에서는 **프라이머리 키를 생성할 때 인덱스를 자동으로 함께 생성**한다.
- **외래 키(Foreign Key) 인덱스**: MySQL의 경우 외래 키 지정 시 자동으로 인덱스가 생성되지만, 다른 RDBMS는 그렇지 않은 경우가 있어 조인 성능에 영향을 줄 수 있으므로 주의해야 한다.

**5. 다중 컬럼 인덱스 (Multi-column Index / Composite Index)**
두 개 이상의 애트리뷰트로 구성된 인덱스를 **다중 컬럼 인덱스** 또는 **컴파짓 인덱스**라고 부른다.
예시: `team_id`와 `back_number`로 구성된 인덱스.

- **정렬 순서의 중요성**: 다중 컬럼 인덱스에서는 애트리뷰트의 순서가 매우 중요하다. 인덱스 생성 시 명시된 **왼쪽의 애트리뷰트부터 우선순위로 정렬**된다. 예를 들어 `(A, B)`로 인덱스를 만들면 A를 먼저 기준으로 정렬하고, A의 값이 같을 경우 B를 기준으로 정렬한다.

- **쿼리 성능 영향**:
  - `WHERE A = 7 AND B = 95`와 같이 인덱스에 포함된 모든 애트리뷰트를 조건으로 사용할 경우, 다중 컬럼 인덱스를 통해 매우 빠르게 데이터를 찾을 수 있다.
  - `WHERE B = 95`와 같이 인덱스의 두 번째 애트리뷰트(B)만을 조건으로 사용할 경우, 인덱스는 첫 번째 애트리뷰트(A)를 기준으로 정렬되어 있으므로 B만으로는 정렬되어 있지 않다. 따라서 이 인덱스는 **사용되지 않거나 성능 향상에 거의 기여하지 못한다**. 이 경우, B에 대한 별도의 인덱스가 필요할 수 있다.

**6. 커버링 인덱스 (Covering Index)**
커버링 인덱스는 **조회하려는 모든 애트리뷰트가 인덱스 내에 포함**되어 있는 인덱스이다.
예시: `team_id`와 `back_number`로 구성된 인덱스가 있는데, 쿼리가 `SELECT team_id, back_number FROM player WHERE team_id = 5`인 경우.
이 경우, 데이터베이스는 실제 테이블까지 찾아가지 않고 **인덱스만으로 쿼리 실행에 필요한 모든 정보를 얻을 수 있으므로**, 조회 성능이 크게 향상된다. 개발자는 의도적으로 커버링 인덱스를 설계하여 조회 성능을 최적화하기도 한다.

**7. 해쉬 인덱스 (Hash Index)**
B-트리 인덱스 외에도 해쉬 테이블을 사용한 **해쉬 인덱스**가 있다.

- **시간 복잡도**: 조회 시 시간 복잡도는 **O(1)**로 매우 빠르다.
- **단점**:
  _ **리해싱(Rehashing) 부담**: 해쉬 테이블의 크기 확장(리해싱) 시 오버헤드가 발생할 수 있다.
  _ **동일 여부 비교만 가능**: `WHERE` 절에서 `=` 연산을 통한 동일 값 비교만 가능하며, `<`, `>`와 같은 **범위 비교 조건으로는 사용할 수 없다**. \* **다중 컬럼 인덱스 제약**: `(A, B)`로 구성된 해쉬 인덱스는 **A와 B 모두를 포함하는 조건**(`WHERE A = val1 AND B = val2`)에서만 사용 가능하며, **일부 애트리뷰트만 사용하는 조건**(`WHERE A = val1`)에서는 사용할 수 없다.
  이러한 제약 사항 때문에 일반적으로 B-트리 기반 인덱스가 더 많이 사용된다.

**8. 풀스캔(Full Scan)이 더 좋은 경우**
항상 인덱스를 사용하는 것이 좋은 것은 아니다. 다음 두 가지 경우에는 풀스캔이 인덱스 사용보다 더 효율적일 수 있다.

- **테이블 데이터가 매우 적은 경우**: 튜플이 수십, 수백 개 정도라면 인덱스 탐색 과정의 오버헤드 때문에 풀스캔이 더 빠르거나 성능 차이가 거의 없다.
- **조회하려는 데이터가 테이블의 상당 부분을 차지하는 경우**: 전체 데이터 중 절반 이상 또는 많은 부분을 조회하는 쿼리의 경우, 인덱스를 사용하는 것보다 풀스캔이 더 효율적일 수 있다. 예를 들어, 100만 명의 고객 중 수십만 명의 특정 통신사 고객을 조회하는 경우.
  데이터베이스의 **옵티마이저(Optimizer)**가 이러한 상황을 판단하여 인덱스 사용 여부 또는 풀스캔 여부를 결정한다.

**9. 인덱스 관리 및 활용 팁**

- **인덱스 정보 확인**: 특정 테이블에 어떤 인덱스들이 걸려 있는지 확인하려면 MySQL에서 `SHOW INDEXES FROM [테이블_이름];` 명령어를 사용한다. 이 명령은 인덱스 이름, 유니크 여부, 구성 애트리뷰트, NULL 허용 여부 등 상세 정보를 보여준다.

- **쿼리 시 인덱스 사용 확인**: 실행하려는 쿼리가 어떤 인덱스를 사용하는지 확인하려면 쿼리 앞에 `EXPLAIN` 키워드를 붙인다.
  `EXPLAIN SELECT * FROM player WHERE back_number = 7;`
  이 명령의 결과에서 `possible_keys` (사용 가능한 키)와 `key` (실제로 사용된 키) 정보를 통해 옵티마이저가 어떤 인덱스를 선택했는지 알 수 있다.

- **옵티마이저의 인덱스 선택 제어**: 대부분의 경우 옵티마이저가 최적의 인덱스를 자동으로 선택하지만, 간혹 옵티마이저가 비효율적인 인덱스를 선택할 수도 있다. 이때 개발자가 특정 인덱스 사용을 명시하거나 제외할 수 있다.
  - `USE INDEX [인덱스_이름]`: 특정 인덱스 사용을 권장한다.
  - `FORCE INDEX [인덱스_이름]`: 특정 인덱스 사용을 강제한다. 단, 해당 인덱스로 데이터를 가져올 수 없는 경우 풀스캔을 수행한다.
  - `IGNORE INDEX [인덱스_이름]`: 특정 인덱스 사용을 제외한다.

**10. 인덱스 사용 시 주의사항**
인덱스는 성능 향상에 도움이 되지만, 무분별한 생성은 오히려 독이 될 수 있다.

- **라이트(INSERT, UPDATE, DELETE) 작업 오버헤드**: 테이블에 새로운 데이터가 추가되거나 기존 데이터가 변경, 삭제될 때마다 해당 인덱스도 함께 변경(트리 구조 조정)되어야 한다. 인덱스가 많을수록 이 오버헤드가 커져 라이트 작업 성능이 저하될 수 있다.
- **추가 저장 공간 소모**: 인덱스 하나당 별도의 데이터(인덱스 데이터)가 생성되므로, 저장 공간을 추가로 차지한다.
- **불필요한 인덱스 생성 금지**: 이미 존재하는 인덱스로 충분히 커버되는 쿼리에 대해 추가적인 인덱스를 만들면, 성능 이점 없이 저장 공간만 낭비하고 라이트 오버헤드만 늘릴 뿐이다.
- **대규모 테이블에 인덱스 생성 시 주의**: 수백만 건 이상의 데이터가 있는 테이블에 인덱스를 생성할 경우, 작업 시간이 몇 분에서 10분 이상 소요될 수 있으며 이 시간 동안 데이터베이스 성능에 영향을 줄 수 있다. 특히 `INSERT`, `UPDATE`, `DELETE`가 빈번한 서비스에서는 트래픽이 적은 시간에 인덱스 생성 작업을 수행하는 것이 좋다.
- **RDBMS 및 옵티마이저 차이**: 인덱스 관련 SQL 명령문이나 동작 방식은 RDBMS마다 조금씩 다를 수 있으며, 옵티마이저의 판단에 따라 인덱스 사용 여부가 달라질 수 있다. 따라서 쿼리 성능 문제가 발생하면 항상 `EXPLAIN` 키워드를 사용하여 실제 동작을 확인하는 것이 중요하다.

결론적으로, 데이터베이스 인덱스는 쿼리 성능 최적화를 위한 필수적인 요소이다. 하지만 효과적인 활용을 위해서는 그 동작 방식과 장단점, 그리고 적절한 관리 방법을 이해하고 쿼리에 맞춰 신중하게 설계해야 한다.
