## DBCP

데이터베이스 커넥션 풀(DBCP)이 무엇이며, 백엔드 성능에 왜 중요한지, 그리고 DBCP를 어떻게 튜닝하는지에 대한 내용을 다룬다. 백엔드 시스템 개발에 있어 DBCP는 기본적으로 항상 사용되는 기술이므로, 그 동작 방식과 장점을 잘 이해하는 것이 중요하다.

### 1. DBCP 개념 및 필요성

일반적으로 백엔드 서버와 DB 서버는 서로 다른 컴퓨터에서 동작한다. 이 두 서버 간의 통신은 **TCP 기반**으로 이루어진다. TCP는 연결 지향적인 특성을 가지므로, 실제 데이터를 주고받기 전에 **커넥션(연결)을 맺는 과정**과 데이터 송수신이 끝난 후 **연결을 끊는 과정**이 반드시 필요하다.

- **TCP 커넥션 수립 및 종료의 시간 비용**:

  - TCP 커넥션을 맺을 때는 **쓰리웨이 핸드셰이크(3-way handshake)**, 끊을 때는 **포웨이 핸드셰이크(4-way handshake)** 과정이 필요하다.
  - 이 과정들은 여러 번의 데이터 송수신을 포함하므로, 생각보다 많은 시간을 소모한다.
  - 백엔드 서버는 API 요청을 처리할 때마다 DB에 접근해야 하는 경우가 많고, 한 API가 여러 번 DB에 접근할 수도 있다. 이때마다 매번 커넥션을 열고 닫는 과정에서 지속적으로 시간 비용이 발생한다.
  - 이러한 시간 비용은 결국 API 응답 시간을 늘려 서비스 성능에 좋지 않은 영향을 준다.

- **DBCP의 등장**:
  - 위와 같은 문제점을 해결하기 위해 고안된 것이 바로 **데이터베이스 커넥션 풀(DBCP)**이다.
  - DBCP는 애플리케이션 서버를 시작할 때(API 요청을 받기 전에) **미리 필요한 DB 커넥션들을 맺어 놓는다**.
  - 이렇게 미리 연결된 커넥션들을 마치 **풀(pool)처럼 관리**한다.
  - API 요청으로 인해 DB에 데이터를 조회할 일이 생기면, DBCP는 새로 커넥션을 맺는 대신, 이미 풀에 만들어져 있는 **놀고 있는(idle) 커넥션을 하나 빌려온다**.
  - 쿼리 처리가 끝난 후 커넥션을 닫을 때, 실제 커넥션을 종료하는 것이 아니라, 빌려온 커넥션을 **다시 커넥션 풀에 반납**한다.
  - 이처럼 커넥션을 미리 만들어 놓고 재사용하는 방식으로 동작하여, **커넥션을 열고 닫는 시간을 절약**할 수 있다.
  - 결과적으로 API 요청 처리 및 응답 시간이 줄어들어 **백엔드 전체 성능 향상**에 기여한다.

### 2. MySQL DB 서버 설정 파라미터

DBCP 설정을 이해하려면 백엔드 서버와 DB 서버 양쪽의 설정 방법을 알아야 한다. MySQL DB 서버에서 중요하게 사용되는 두 가지 파라미터를 살펴본다.

- **`max_connections`**:

  - **정의**: 클라이언트와 맺을 수 있는 **최대 커넥션 수**를 의미한다. DB 서버 입장에서 클라이언트는 DB 서버에 요청을 보내는 모든 대상을 말하며, 이 예제에서는 백엔드 서버가 클라이언트가 된다.
  - **중요성**: 이 파라미터는 새로 백엔드 서버를 투입하거나 DBCP의 커넥션 수를 늘릴 때 에러가 발생하지 않도록 **충분히 적절한 값으로 설정**되어야 한다.
  - **예시**: MySQL의 `max_connections`가 4이고, 이미 두 백엔드 서버의 DBCP가 각각 2개의 커넥션(총 4개)을 맺고 있는 상황에서, 세 번째 백엔드 서버를 투입하면 새로운 커넥션을 맺을 수 없게 된다.

- **`wait_timeout`**:
  - **정의**: DB 서버에서 **비활성(inactive) 상태인 커넥션(놀고 있는 커넥션)**이 새로운 요청을 기다리다가, 일정 시간 동안 요청이 오지 않으면 **자동으로 커넥션을 끊을 것인지**를 결정하는 파라미터이다.
  - **필요성**:
    - 정상적인 종료 절차 없이 비정상적으로 커넥션이 종료되거나, 커넥션을 빌려간 백엔드 서버가 버그로 인해 커넥션을 풀에 반환하지 않는 경우(즉, 커넥션이 점유는 되어 있지만 사용되지 않는 이상한 상태)가 발생할 수 있다.
    - 중간에 네트워크 단절이 발생하여 DB 서버가 클라이언트로부터 데이터를 받지 못하는 상황도 있을 수 있다.
    - 이러한 비정상적인 커넥션들이 계속 열려 있는 상태로 남아있으면 DB 서버의 리소스를 계속 점유하게 되어 **DB 서버에 좋지 않은 영향을 줄 수 있다**.
  - **동작 방식**: `wait_timeout`을 60초로 설정했다면, 마지막 요청을 받은 시점부터 60초를 기다린다. 60초 내에 요청이 오지 않으면 DB 서버가 해당 커넥션을 끊어 리소스를 반환한다. 만약 60초가 되기 전에 새로운 요청이 들어오면, 커넥션이 요청을 처리한 후 `wait_timeout` 카운트가 다시 0으로 초기화된다.

### 3. 히카리CP (백엔드 서버) 설정 파라미터

스프링 부트 2.0부터 기본 DBCP로 채택된 히카리CP(HikariCP)를 기준으로 백엔드 서버의 DBCP 설정을 살펴본다.

- **`minimumIdle`**:

  - **정의**: 커넥션 풀에서 **유지하는 최소한의 아이들(idle) 커넥션 수**를 의미한다.
  - 아이들 커넥션은 연결은 되어 있지만, 현재 어떤 작업을 처리하지 않고 쉬고 있는 커넥션을 말한다.

- **`maximumPoolSize`**:

  - **정의**: 커넥션 풀이 가질 수 있는 **최대 커넥션 수**를 의미한다.
  - 여기서 최대 커넥션 수는 **아이들 커넥션과 액티브(in-use) 커넥션을 합친 총 커넥션 수**를 말한다.
  - **`minimumIdle`과의 동작 연관성**:
    - 만약 DBCP 내의 아이들 커넥션 수가 `minimumIdle` 값보다 작고, 동시에 전체 커넥션 수도 `maximumPoolSize`보다 작다면, DBCP는 **추가로 커넥션을 생성**한다.
    - **`maximumPoolSize`가 `minimumIdle`보다 우선순위가 높다**. 즉, `maximumPoolSize`에 도달하면 더 이상 커넥션을 추가하지 않는다.

- **권장 사항: 고정 풀 사이즈 사용**:

  - 히카리CP 공식 문서에 따르면, `minimumIdle`의 기본값은 `maximumPoolSize`와 동일하다.
  - **`minimumIdle`과 `maximumPoolSize` 값을 동일하게 설정하여 풀 사이즈를 고정하는 것을 권장**한다.
  - **이유**: 커넥션을 생성하는 과정은 시간이 걸리는 작업이므로, 트래픽이 빠르게 몰려올 때 커넥션 생성 속도가 트래픽 증가 속도보다 느리면 백엔드 서버가 제대로 반응하지 못하고 응답이 지연될 수 있다. 따라서 처음부터 적절한 개수로 풀 사이즈를 고정하여 사용하는 것이 좋다. 실제 개발 실무에서도 이와 같은 방식으로 풀 사이즈를 넉넉하게 설정하여 사용한다.

- **`maxLifetime`**:

  - **정의**: 풀에 있는 커넥션의 **최대 수명**을 의미한다.
  - **동작 방식**:
    - 커넥션의 수명이 `maxLifetime`을 초과했을 때, 해당 커넥션이 **아이들 상태이면 풀에서 즉시 제거**된다.
    - 커넥션이 **액티브 상태이면, 풀로 반환된 후에 제거**된다.
    - 풀 사이즈가 고정으로 설정된 경우, 커넥션이 제거되면 **즉시 새로운 커넥션을 만들어 풀 사이즈를 유지**한다.
  - **중요 포인트 (커넥션 누수 방지)**:
    - **다 쓴 커넥션은 반드시 풀로 반환되도록 코드를 잘 작성해야 한다**.
    - 만약 커넥션이 풀로 반환되지 않으면, 액티브 상태로 인식되어 `maxLifetime`이 동작하지 않고 계속 살아있을 수 있다. 이는 **커넥션 누수(leak) 현상**으로 이어질 수 있다.
    - 이런 경우 DB 서버의 `wait_timeout` 설정이 커넥션을 끊어주어 리소스를 반환할 수 있지만, 이후 해당 커넥션을 사용하려는 요청은 이미 끊긴 커넥션에 대해 `Exception`을 발생시킬 수 있다.

- **`maxLifetime`과 DB `wait_timeout` 간의 관계**:

  - **`maxLifetime`은 DB 서버의 `wait_timeout`보다 2~5초 정도 짧게 설정하는 것이 중요하다**.
  - **이유**: 만약 두 값이 동일하게 설정되면, 백엔드 서버에서 쿼리를 보낸 직후 DB 서버가 `wait_timeout`에 도달하여 커넥션을 끊어버릴 수 있다. 이 경우 쿼리가 DB에 도착하기 전에 커넥션이 끊겨 `Exception`이 발생할 수 있다. `maxLifetime`을 DB의 타임아웃보다 짧게 설정함으로써, DBCP가 먼저 커넥션을 정리하고 새로운 커넥션을 확보할 시간을 벌어주는 것이다.

- **`connectionTimeout`**:
  - **정의**: DBCP로부터 **커넥션을 받기 위해 기다리는 최대 시간**을 의미한다.
  - **필요성**: 트래픽이 몰려 모든 커넥션이 액티브 상태가 되어 당장 사용할 수 있는 커넥션이 없을 때, 무한정 기다릴 수 없으므로 특정 시간 이후에 타임아웃되어 `Exception`을 발생시킨다.
  - **설정 고려사항**: 이 값은 **사용자 경험**을 고려하여 적절하게 설정해야 한다. 예를 들어 일반 사용자가 30초까지 응답을 기다리지 않으므로, 사용자로부터 온 요청이라면 10초 이내로 짧게 설정하는 것이 더 적절할 수 있다.

### 4. 적절한 커넥션 수 찾기 (튜닝 과정)

적절한 커넥션 수를 찾는 과정은 팀의 상황과 목표에 따라 달라질 수 있지만, 일반적인 접근 방식을 제시한다.

- **DB 서버 구성 고려**:

  - 실제 백엔드 시스템에서는 고가용성을 위해 DB 서버를 **레플리케이션(Replication) 구성**으로 운영한다.
  - 프라이머리 서버는 읽기(read)와 쓰기(write) 쿼리를 모두 처리하고, 세컨더리 서버는 읽기 전용(read-only) 쿼리를 처리하도록 구성할 수 있다.
  - 적절한 커넥션 수 탐색 예시에서는 이해의 편의를 위해 프라이머리 서버에 집중하여 설명한다.

- **적절한 커넥션 수 탐색 과정 (개인적인 방식)**:
  - **1. 모니터링 환경 구축**: 평소에도 백엔드 시스템의 모니터링 환경이 구축되어 있어야 예상치 못한 상황이나 장애 발생 시 빠르게 원인을 파악할 수 있다.
  - **2. 부하 테스트 수행**:
    - **툴**: 네이버의 NGrinder와 같은 부하 테스트 툴을 활용한다.
    - **과정**: 백엔드 시스템에 요청 수를 점진적으로 늘려가면서(트래픽 증가) 시스템의 동작을 관찰한다.
    - **관찰 지표**:
      - **RPS (Requests Per Second)**: 초당 처리할 수 있는 리퀘스트 수. 백엔드 시스템의 전체 처리량을 보여준다. 트래픽을 늘리면 RPS도 증가하다가 **어느 순간 더 이상 늘어나지 않고 꺾이는 지점**이 발생한다.
      - **Average Response Time**: 리퀘스트 처리의 평균 응답 시간. API 성능을 보여주는 지표이다. 부하를 늘려도 **어느 순간까지는 일정하게 유지되다가 이후부터 응답 시간이 점진적으로 늘어나는 지점**이 발생한다.
  - **3. 리소스 사용률 확인**:
    - 부하 테스트 중 **백엔드 서버와 DB 서버의 CPU, 메모리 등의 리소스 사용률**을 지속적으로 확인한다.
    - **백엔드 서버 리소스 과부하**: CPU/메모리 사용량이 60~80% 이상으로 올라가면, 현재 서버 수로는 트래픽을 감당하기 어렵다는 의미이므로 **백엔드 서버를 추가**하여 트래픽을 분산시켜야 한다.
    - **DB 서버 리소스 과부하**: 백엔드 서버는 괜찮은데 DB 서버의 CPU/메모리 사용량이 급증하면, DB 부하를 낮추기 위한 조치가 필요하다.
      - 해결 방안: 읽기 쿼리가 많다면 세컨더리 서버 추가, 백엔드와 DB 사이에 캐시 레이어 도입, 샤딩(Sharding) 등.
  - **4. 병목 현상 분석 및 DBCP 튜닝**:
    - 리소스 사용률은 괜찮은데 RPS 그래프가 꺾이거나 응답 시간이 늘어나는 현상이 발생한다면, 다른 병목 원인을 찾는다.
    - **쓰레드 풀 확인**: `쓰레드 퍼 리퀘스트` 모델이라면, 요청을 처리하는 쓰레드 풀의 **액티브 쓰레드 수**를 확인한다. 만약 액티브 쓰레드 수가 전체 쓰레드 수와 거의 같다면, 쓰레드 풀 사이즈가 작아서 병목이 발생했을 수 있으므로 **쓰레드 풀의 쓰레드 수를 늘려준다**.
    - **DBCP 액티브 커넥션 수 확인**: 만약 쓰레드 풀이 여유로운데도 성능 저하가 발생한다면, **DBCP의 액티브 커넥션 수**를 확인한다.
      - 만약 DBCP의 `maximumPoolSize`가 5인데, 부하 시점에 액티브 커넥션 수가 5개 중 5개로 모두 사용되고 있다면, **커넥션 수가 너무 적어서 문제일 가능성**이 높다.
      - 이 경우, **`maximumPoolSize`를 점진적으로 (예: 5 -> 10 -> 15) 늘려가며 다시 부하 테스트를 반복**한다.
      - `maximumPoolSize`가 MySQL의 `max_connections` (예: 30)에 도달했는데도 성능에 여유가 있다면, **MySQL의 `max_connections` 값 자체를 높여 (예: 30 -> 60) 다시 테스트**를 진행한다.
  - **5. 최종 DBCP 풀 사이즈 결정**:
    - 부하 테스트를 통해 DB 서버의 적절한 `max_connections` 값(예: 60)이 확인되면, 이를 기준으로 백엔드 서버의 수와 각 DBCP의 `maximumPoolSize`를 결정한다.
    - **예시**: DB의 `max_connections`가 60이고 백엔드 서버가 2대라면, 각 서버의 `maximumPoolSize`를 25로 설정하여 총 50개의 커넥션을 사용하고 10개의 여유를 둘 수 있다.
    - **유연한 설정**: 필요에 따라 백엔드 서버를 추가하고 (예: 3대) 각 서버의 `maximumPoolSize`를 줄여(예: 15로, 총 45개) 운영할 수도 있다. 갑작스러운 트래픽 증가에 대비하여 예비 서버를 고려하여 DBCP 사이즈를 결정하는 것도 가능하다.

**핵심**: 위와 같이 **종합적인 고려와 반복적인 부하 테스트를 통해 적절한 커넥션 수를 설정**할 수 있다. 먼저 DB의 `max_connections`를 찾고, 이를 바탕으로 백엔드 서버 수에 맞춰 각 DBCP의 `maximumPoolSize`를 결정하는 것이 중요하다.

**참고 사항**:

- 부하 테스트는 실제 운영 서버에서 진행할 수도 있지만, 실제 사용자에게 영향을 줄 수 있으므로 트래픽이 적은 시간대에 진행하는 것을 권장한다.
- 사용 중인 DBCP (예: Commons DBCP 등)의 특정 사용법을 잘 숙지하는 것이 중요하다.
