## 데이터베이스 설계의 기본: 함수 종속 (Functional Dependency, FD) 제대로 파악하기

데이터베이스를 설계하는 데 있어 가장 기본적이면서도 중요한 개념 중 하나가 바로 **함수 종속(Functional Dependency, FD)**이다. 함수 종속은 데이터베이스 테이블 내의 두 속성(Attribute) 집합 사이에 존재하는 제약 관계를 의미한다. 데이터베이스 정규화의 핵심 개념이다.

### 함수 종속이란 무엇일까?

함수 종속은 간단히 말해 **한 속성(또는 속성 집합)의 값이 다른 속성(또는 속성 집합)의 값을 유일하게 결정하는 관계**를 말한다. 이를 기호로는 **X → Y**로 표현하며, **'X가 Y를 함수적으로 결정한다'** 혹은 **'Y가 X에 함수적으로 의존한다'**고 읽는다.

예를 들어, `직원(Employee)` 테이블에 직원 ID, 이름, 생일, 직군, 연봉 등의 속성이 있다고 가정해보자.

- **집합 X**: 직원 ID
- **집합 Y**: 직원 이름, 생일, 직군, 연봉

이 경우, **직원 ID → {직원 이름, 생일, 직군, 연봉}** 이라는 함수 종속이 성립한다. 왜냐하면 직원 ID는 각 직원마다 유니크하게 부여되는 식별자이므로, 동일한 직원 ID를 가진 두 튜플이 있다면 그 직원의 이름, 생일, 직군, 연봉 또한 모두 동일할 수밖에 없기 때문이다. 즉, **X의 값이 같다면 Y의 값도 당연히 같아지는 관계**가 바로 함수 종속이다.

### 함수 종속, 어떻게 파악해야 할까?

함수 종속을 파악할 때는 테이블의 현재 데이터(상태, state)만 보고 판단해서는 안 된다. **테이블의 스키마를 보고 속성들 사이의 의미적인 관계를 파악**해야 한다.

예를 들어, `직원` 테이블에 직원 이름과 생일 정보가 있고, 현재 데이터에 동명이인이 없어 직원 이름과 생일이 일대일로 매칭된다고 해도 **'직원 이름 → 생일'** 이라는 함수 종속이 존재한다고 섣불리 판단하면 안 된다. 왜냐하면 나중에 동명이인이 입사하여 같은 이름을 가졌지만 다른 생일을 가지는 경우가 발생할 수 있기 때문이다. 이런 경우 '직원 이름 → 생일' 함수 종속은 더 이상 성립하지 않는다.

마찬가지로, 직원 ID가 직원 이름, 생일, 직군, 연봉, 부서 ID를 결정하는지 여부도 회사의 정책에 따라 달라질 수 있다. 만약 회사의 정책이 "모든 직원은 반드시 하나의 부서에만 속해야 한다"면 직원 ID는 부서 ID를 포함한 나머지 정보를 결정할 수 있다. 하지만 "직원이 하나 이상의 부서에 속할 수도 있다"면, 같은 직원 ID를 가진 직원이 여러 부서에 속할 수 있으므로 직원 ID만으로는 부서 ID를 결정할 수 없게 된다.

결론적으로, 구축하려는 데이터베이스의 속성들이 관계적으로 어떤 의미를 지닐지에 따라 함수 종속이 달라질 수 있으므로, **의미적으로 잘 파악하는 것이 매우 중요하다**.

함수 종속 기호에서 화살표 왼쪽 부분은 **Left Hand Side (LHS)**, 오른쪽 부분은 **Right Hand Side (RHS)**라고 부른다.

**다양한 함수 종속의 예시:**

- **학생 ID → {이름, 생일, 주소}**: 학생 ID는 학생을 식별하는 유니크한 값이므로, 학생 ID가 같으면 이름, 생일, 주소도 당연히 같다.
- **강의 ID → {강의 이름, 개설 연도, 학기, 학점}**: 강의 ID는 강의를 식별하므로, 강의 ID가 같으면 나머지 정보도 같다.
- **{학생 ID, 강의 ID} → 성적**: 한 학생이 여러 수업을 듣고, 한 수업에 여러 학생이 있으므로 학생 ID만으로는 성적을 특정할 수 없고, 강의 ID만으로도 성적을 특정할 수 없다. 하지만 학생 ID와 강의 ID가 함께 있으면 해당 학생이 해당 수업에서 받은 성적을 유일하게 결정할 수 있다.
- **{은행 이름, 계좌 번호} → {잔액, 개설 날짜}**: 서로 다른 은행에서 같은 계좌번호가 우연히 존재할 수 있으므로 계좌번호만으로는 계좌 정보를 결정할 수 없다. 은행 이름과 계좌 번호가 함께 있어야 정확한 계좌의 잔액과 개설 날짜를 결정할 수 있다.
- **{사용자 ID, 위치 ID, 방문 날짜} → 코멘트, 사진 URL**: 위치 기반 SNS에서 특정 사용자가 특정 위치를 특정 날짜에 방문했을 때 남긴 코멘트나 사진 URL을 결정하기 위해서는 이 세 가지 정보가 모두 필요하다.

### 함수 종속의 방향성

X → Y 함수 종속이 존재한다고 해서 **Y → X 함수 종속이 반드시 존재하는 것은 아니다**.

- **직원 ID → 직원 이름**: 직원 ID가 같으면 직원 이름도 당연히 같다.
- **직원 이름 → 직원 ID**: 하지만 직원 이름이 같다고 해서 직원 ID가 같다는 보장은 없다. 동명이인이 존재할 수 있기 때문이다. 따라서 '직원 이름 → 직원 ID' 함수 종속은 성립하지 않는다.

그러나 경우에 따라서는 양방향 함수 종속이 성립할 수도 있다.

- **직원 ID → 주민등록번호**
- **주민등록번호 → 직원 ID**: 주민등록번호는 각 사람마다 유일한 식별자이므로, 주민등록번호가 같으면 직원 ID도 당연히 같다.

이처럼 함수 종속은 존재 여부와 방향이 속성들의 의미에 따라 달라진다.

### 특이한 함수 종속: 공집합이 결정자일 때

교과서에서 잘 다루지 않는 개념 중 하나로, **왼쪽(LHS)이 공집합(Ø)인 함수 종속**도 존재한다.
**Ø → Y**

이는 **Y의 값이 언제나 하나의 값만을 가진다**는 의미이다.

예를 들어, `프로젝트(Project)` 테이블에 프로젝트 ID, 이름, 시작 날짜, 종료 날짜, 리더 ID 외에 `회사` 속성이 있다고 해보자. 처음에는 여러 회사의 이름이 들어갈 수 있을 것으로 가정했지만, 결국 이 테이블에 저장되는 모든 프로젝트가 항상 **'특정 한 회사'**의 프로젝트만 다루게 된다면, `회사` 속성은 항상 동일한 값을 가지게 된다. 이 경우 `회사` 속성은 다른 특정 속성에 따라 값이 바뀌는 것이 아니라 항상 동일한 값을 가지므로, **Ø → 회사** 라는 함수 종속으로 표현할 수 있다. 이 개념은 **제2정규형(Second Normal Form, 2NF)**과 관련이 있으니 잘 기억해두는 것이 좋다.

### 함수 종속의 종류

함수 종속은 다양한 관점에서 분류할 수 있다.

#### 1. 자명 함수 종속 (Trivial Functional Dependency)

**X → Y 함수 종속이 유효할 때, 만약 Y가 X의 부분집합이라면** 이 함수 종속을 **자명 함수 종속**이라고 한다.

- 예시: {A, B, C} → C
  - RHS인 C가 LHS인 {A, B, C}의 부분집합이므로 자명 함수 종속이다.
- 예시: {A, B, C} → {A, C}
  - RHS인 {A, C}가 LHS인 {A, B, C}의 부분집합이므로 자명 함수 종속이다.
- 예시: {A, B, C} → {A, B, C}
  - 동일한 집합도 부분집합으로 볼 수 있으므로 자명 함수 종속이다.

#### 2. 비자명 함수 종속 (Non-Trivial Functional Dependency)

**X → Y 함수 종속이 유효할 때, 만약 Y가 X의 부분집합이 아니라면** 이 함수 종속을 **비자명 함수 종속**이라고 한다.

- 예시: {A, B, C} → {C, D}
  - RHS인 {C, D}가 LHS인 {A, B, C}의 부분집합이 아니다 (D가 LHS에 없음). 따라서 비자명 함수 종속이다.
  - 참고로, C는 겹치지만 D는 겹치지 않으므로 '완전 비자명 함수 종속'은 아니다.
- 예시: {A, B} → {C, D}
  - RHS인 {C, D}가 LHS인 {A, B}의 부분집합이 아니다.

특히, **X와 Y 사이에 공통된 속성이 하나도 없을 때**는 **완전 비자명 함수 종속 (Completely Non-Trivial Functional Dependency)**이라고 부른다. 위의 예시 중 {A, B} → {C, D}는 완전 비자명 함수 종속에 해당한다.

#### 3. 부분 함수 종속 (Partial Functional Dependency)

**X → Y 함수 종속이 존재할 때, LHS인 X의 '프로퍼 서브셋(Proper Subset)' 중 어떤 하나라도 Y를 결정할 수 있다면** 이 함수 종속을 **부분 함수 종속**이라고 한다.

여기서 **프로퍼 서브셋**이란 '부분집합이지만 원래 집합과는 동일하지 않은 집합'을 의미한다. 예를 들어, 집합 X가 {A, B, C}라면, {A, C}, {A}, 공집합 등은 X의 프로퍼 서브셋이지만 {A, B, C} 자체는 프로퍼 서브셋이 아니다. 즉, 원래 집합에서 **최소한 하나의 속성이라도 제거된 집합**을 의미한다.

- 예시: {직원 ID, 직원 이름} → 생일
  - 이 함수 종속은 실제로 유효하다.
  - 하지만 이 LHS의 프로퍼 서브셋인 **'직원 ID'만으로도 생일을 결정할 수 있다**. 직원 ID는 직원마다 유니크하므로 직원 ID가 같으면 생일도 당연히 같기 때문이다.
  - 따라서 **{직원 ID, 직원 이름} → 생일**은 **부분 함수 종속**이다.

#### 4. 완전 함수 종속 (Full Functional Dependency)

**X → Y 함수 종속이 존재할 때, LHS인 X의 '어떤 프로퍼 서브셋'도 Y를 결정할 수 없다면** 이 함수 종속을 **완전 함수 종속**이라고 한다. 즉, **X의 어떤 속성을 제거해도 더 이상 Y를 결정할 수 없을 때**를 의미한다.

- 예시: {학생 ID, 강의 ID} → 성적
  - 이 함수 종속은 유효하다.
  - 이 LHS의 프로퍼 서브셋은 '학생 ID', '강의 ID', 그리고 공집합이 있다.
  - **학생 ID만으로는 성적을 결정할 수 없다**: 한 학생이 여러 수업을 들을 수 있고, 각 수업마다 다른 성적을 받을 수 있기 때문이다.
  - **강의 ID만으로는 성적을 결정할 수 없다**: 한 수업에 여러 학생이 있고, 각 학생마다 다른 성적을 받을 수 있기 때문이다.
  - 공집합은 당연히 성적을 결정할 수 없다.
  - 따라서 **{학생 ID, 강의 ID} → 성적**은 **완전 함수 종속**이다.

부분 함수 종속과 완전 함수 종속의 개념은 **정규화 과정에서 매우 중요하게 사용**되므로, 이 둘의 차이를 명확히 이해하고 있는 것이 좋다.
