## 1. B-Tree의 핵심 용어 정리

B-Tree를 제대로 이해하려면 먼저 몇 가지 기본 용어를 알아야 한다. B-Tree의 모든 동작은 이 규칙들을 기반으로 한다.

- **`m` (최대 자식 수):** 하나의 노드가 가질 수 있는 **자식 노드의 최대 개수**이다. 이 `m` 값을 '차수(Order)'라고 부르며, 이 값이 B-Tree의 모양을 결정한다.
- **`m-1` (최대 키 수):** 하나의 노드에 저장할 수 있는 **키(Key)의 최대 개수**이다. 자식 노드들은 항상 키에 의해 정렬 및 분리되므로, 키의 개수는 자식 수보다 항상 하나 적다.
- **`⌈m/2⌉` (최소 자식 수):** 루트 노드를 제외한 모든 노드가 가져야 하는 **자식 노드의 최소 개수**이다. 이 규칙 덕분에 트리가 한쪽으로 치우치지 않고 항상 균형 잡힌 상태를 유지할 수 있다.
- **`⌈m/2⌉ - 1` (최소 키 수):** 루트 노드를 제외한 모든 노드가 가져야 하는 **키의 최소 개수**이다. 만약 노드의 키 개수가 이보다 적어지면 **`Underflow(Underflow)`** 가 발생하며, 트리의 균형을 위해 재조정 작업이 일어난다.

---

## 2. B-Tree의 삽입(Insertion) 과정

B-Tree에 새로운 데이터를 넣는 과정은 간단한 원칙 두 가지만 기억하면 된다다.

### 2.1 원칙

1.  새로운 키는 **반드시 리프 노드(Leaf Node)에 추가**한다.
2.  노드가 가득 차면(**`Overflow`**), 노드를 **분할(Split)**하고 중간 키를 부모로 **승진(Promotion)** 시킨다.

### 2.2 동작 방식

1.  **탐색:** 먼저, 삽입하려는 키가 어느 리프 노드에 들어가야 하는지 탐색을 통해 찾아간다다.
2.  **리프 노드에 삽입:** 찾은 리프 노드에 새로운 키를 정렬된 순서에 맞게 삽입한다.
3.  **Overflow 처리:** 만약 키를 삽입한 후 노드의 키 개수가 최대치(`m-1`)를 초과하면 **`Overflow`**가 발생한다. 이때 다음 과정을 통해 해결한다.
    - **분할(Split):** 현재 노드의 키들 중에서 중간값을 기준으로 삼는다. 중간값보다 작은 키들은 왼쪽 노드, 큰 키들은 오른쪽 노드로 분할하여 두 개의 새로운 노드를 만든다.
    - **승진(Promotion):** 기준이 되었던 중간 키는 부모 노드로 올려보낸다. 이 중간 키는 방금 분할된 두 노드를 가리키는 역할을 하게된다. 만약 부모 노드에서도 Overflow가 발생하면, 이 분할 및 승진 과정이 루트 노드에 도달할 때까지 재귀적으로 반복된다.

---

## 3. B-Tree의 삭제(Deletion) 과정

삭제는 삽입보다 조금 더 복잡하다. 키가 부족해지는 **`Underflow`** 를 해결해야 한다.

### 3.1 원칙

1.  삭제는 **항상 리프 노드에서** 일어나는 것을 목표로 한다.
2.  삭제 후 키의 개수가 최소치(`⌈m/2⌉ - 1`)보다 작아지면(**`Underflow`**), 형제 노드와 **재분배(Redistribution)** 하거나 **병합(Merge)** 하여 균형을 맞춘다.

### 3.2 동작 방식

1.  **탐색:** 삭제할 키를 찾는다.
2.  **삭제 및 재조정:**
    - **Case 1: 키가 리프 노드에 있는 경우**
      - 단순히 해당 키를 삭제한다.
    - **Case 2: 키가 내부 노드(Internal Node)에 있는 경우**
      - 삭제할 키의 바로 다음 순서인 키(**`Inorder Successor`**)를 리프 노드에서 찾는다. (혹은 바로 이전 순서인 `Inorder Predecessor`를 찾아도 된다.)
      - 내부 노드의 삭제할 키와 리프 노드의 후임 키를 **서로 교환**한다.
      - 이제 삭제할 키는 리프 노드로 이동했으므로, 리프 노드에서 해당 키를 삭제한다. (Case 1로 전환)
3.  **Underflow 처리:** 키를 삭제한 후 노드의 키 개수가 최소치보다 작아지면 **`Underflow`** 가 발생한다. 이때 다음 두 가지 방법 중 하나로 해결한다.
    - **재분배(Redistribution):** 먼저, 삭제된 노드의 바로 왼쪽 또는 오른쪽 형제 노드를 확인한다. 만약 형제 노드가 키를 빌려줄 여유(최소 개수보다 많은 키)가 있다면, 부모 노드의 키를 하나 내려받고 형제 노드의 키를 하나 부모 노드로 올려서 재분배한다. 이 방법이 병합보다 비용이 저렴해서 우선적으로 시도된다.
    - **병합(Merge):** 형제 노드도 키를 빌려줄 여유가 없다면, Underflow가 발생한 노드를 형제 노드와 합친다. 이때 두 노드 사이에 있던 부모 노드의 키도 함께 내려와 새로운 병합 노드의 일부가 된다. 이 병합으로 인해 부모 노드에서 또 Underflow가 발생할 수 있으며, 이 경우 재귀적으로 상위 레벨에서 이 과정을 반복한다.

---

## 왜 데이터베이스 인덱스는 B-Tree를 사용할까?

"B-Tree는 `O(log n)`의 시간 복잡도를 가지는데, 왜 `O(log n)`인 다른 트리(AVL 트리 등) 대신 굳이 B-Tree를 DB 인덱스로 쓰는 걸까요?" 좋은 질문이에요. 답은 **데이터가 저장되는 공간**, 즉 **디스크(보조 기억장치)** 의 특성에 있다.

### 1단계: 근본적인 문제 인식 - "디스크는 메모리보다 훨씬 느리다"

- 데이터베이스의 데이터는 대부분 **HDD나 SSD 같은 보조 기억장치**에 저장된다. 이 장치들은 `RAM` 같은 메인 메모리에 비해 데이터 접근 속도가 치명적으로 느리다.
- 디스크는 데이터를 읽고 쓸 때 바이트 단위가 아닌, **`블록(Block)`이라는 덩어리 단위**로 입출력(`Disk I/O`)을 수행한다. 즉, 1바이트만 필요해도 최소 4KB 같은 블록 하나를 통째로 읽어와야 한다.
- 결론적으로 데이터베이스 성능은 **"얼마나 적은 횟수의 Disk I/O로 원하는 데이터를 찾는가"**에 달려있다.

### 2단계: B-Tree의 구조적 이점 - "느린 디스크에 최적화된 구조"

B-Tree는 이 `Disk I/O`를 최소화하기 위해 설계된 자료구조이다.

- **이점 1: 트리의 높이가 극단적으로 낮다.**

  - B-Tree는 하나의 노드에 수백 개 이상의 많은 키를 저장할 수 있다. 키가 많다는 것은 자식 노드도 많이 가질 수 있다는 뜻이다.
  - 이렇게 트리가 **옆으로 넓어지는(Wide) 대신 높이가 매우 낮아집니다(Shallow)**. 예를 들어, 차수(m)가 101인 3단계 높이의 B-Tree는 약 1억 개의 데이터를 저장할 수 있다.
  - **핵심은, 트리의 높이가 곧 `Disk I/O` 횟수**라는 점이다. 높이가 3이라면, 최악의 경우에도 단 3번의 디스크 접근만으로 데이터를 찾을 수 있다는 의미이다.

- **이점 2: 블록 단위 읽기에 효율적이다 (캐시 효율성).**
  - B-Tree의 노드는 많은 키를 한 곳에 모아두고 있다. 디스크가 하나의 블록을 읽어올 때, 그 블록 안에는 앞으로 탐색에 사용될 가능성이 높은 여러 개의 키들이 함께 담겨있게 된다.
  - 즉, 한 번의 `Disk I/O`로 가져온 데이터 덩어리를 **매우 알차게 활용**할 수 있어 효율적이다.

### 3단계: 다른 자료구조와의 비교

- **vs. `AVL` 트리, `Red-Black` 트리:** 이진 트리는 한 노드에 키가 하나뿐이라 데이터 양이 많아지면 트리의 높이가 매우 깊어집니다. 이는 곧 수많은 `Disk I/O`를 유발하므로 디스크 기반의 데이터베이스에는 적합하지 않습니다. 메모리 상에서만 동작할 때는 훌륭한 자료구조다.
- **vs. `Hash` 인덱스:** 해시 인덱스는 `key = value` 형태의 **동등 조건 검색(`Equality Search`)** 에서는 `O(1)`에 가까운 매우 빠른 속도를 보이다. 하지만 `key > value` 같은 **범위 검색(`Range Search`)** 이나 정렬(Sorting)에는 전혀 사용할 수 없습니다. B-Tree는 키들이 정렬된 상태이므로 범위 검색과 정렬에 매우 효율적이라, 범용성이 훨씬 뛰어나다.
