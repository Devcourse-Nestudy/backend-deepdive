**트랜잭션 동시성 제어의 기초: 회복성 (Recoverability)**

### 1. 언리커버러블 스케줄(Unrecoverable Schedule)

*   **정의:** 스케줄 내에서 커밋(commit)된 트랜잭션이 롤백(rollback)된 트랜잭션이 기록(write)한 데이터를 읽은 경우를 **언리커버러블 스케줄**이라고 한다.
*   **문제 상황 예시:**
    *   K가 H에게 20만원을 이체하는 트랜잭션 1(T1)과 H가 본인 계좌에 30만원을 입금하는 트랜잭션 2(T2)가 동시에 실행되는 스케줄을 가정한다.
    *   T2가 H의 잔액을 읽고 230만원으로 업데이트(write)한다.
    *   T1이 T2가 갱신한 H의 잔액 230만원을 읽고, 20만원을 더해 250만원으로 업데이트(write)한 뒤 커밋한다.
    *   이후 T2에 문제가 발생하여 어보트(abort)되고 롤백된다. 롤백은 트랜잭션의 원자성(Atomicity) 속성에 의해 마치 아무 일도 일어나지 않았던 것처럼 트랜잭션 이전 상태로 되돌려야 한다. 이에 따라 T2는 H의 잔액을 원래 200만원으로 되돌린다.
    *   **문제:** T1은 이미 커밋되었기 때문에, 트랜잭션의 지속성(Durability) 속성 때문에 롤백될 수 없다. 하지만 T1이 읽었던 T2의 데이터(H의 230만원)는 T2의 롤백으로 인해 더 이상 유효하지 않은 데이터가 되었다. 결과적으로 T1은 유효하지 않은 데이터를 기반으로 작업을 완료하고 커밋한 셈이다.
    *   **결과:** 최종적으로 H의 잔액은 T2의 롤백으로 인해 200만원이 되었지만, K의 잔액은 T1에 의해 80만원으로 유지된다. 이로 인해 20만원의 데이터가 사라지는 **데이터 불일치**가 발생한다.
*   **결론:** 언리커버러블 스케줄은 롤백 시 이전 상태로 회복이 불가능할 수 있기 때문에, DBMS에서 **절대 허용해서는 안 되는 스케줄**이다.

### 2. 리커버러블 스케줄(Recoverable Schedule)

*   **정의:** 스케줄 내에서 어떤 트랜잭션도 자신이 읽은 데이터를 기록한 트랜잭션이 먼저 커밋하든 롤백하든, 그 종료 전까지는 커밋하지 않는 스케줄을 **리커버러블 스케줄**이라고 한다. 즉, 자신이 의존하는 트랜잭션(읽은 데이터를 기록한 트랜잭션)이 완전히 완료(커밋 또는 롤백)될 때까지 자신의 커밋을 미루는 스케줄이다.
*   **회복 가능성:** 이러한 스케줄은 롤백 시 이전 상태로 완전히 돌아갈 수 있기 때문에 DBMS에서 허용해야 하는 스케줄이다.
*   **캐스케이딩 롤백(Cascading Rollback) 문제:**
    *   리커버러블 스케줄에서는 하나의 트랜잭션이 롤백되면, 그 트랜잭션이 기록한 데이터를 읽었던 다른 트랜잭션들도 **연쇄적으로 롤백**해야 할 수 있다. 이를 **캐스케이딩 롤백**이라고 한다.
    *   이러한 연쇄적인 롤백은 여러 트랜잭션을 이전 상태로 돌려놓는 데 많은 처리 비용을 발생시킨다.

### 3. 캐스케이드리스 스케줄(Cascadeless Schedule)

*   **정의:** 캐스케이딩 롤백의 문제를 해결하기 위해 제시된 스케줄로, 스케줄 내에서 어떤 트랜잭션도 **커밋되지 않은 트랜잭션이 기록한 데이터를 읽지 않는** 경우를 **캐스케이드리스 스케줄**이라고 한다. 이는 'Avoid Cascading Rollback'이라고도 불린다.
*   **동작 방식:** 데이터를 읽으려는 트랜잭션은 해당 데이터를 기록한 트랜잭션이 **종료(커밋)된 후에만** 읽을 수 있도록 한다.
*   **장점:** 이렇게 하면 만약 데이터를 기록한 트랜잭션이 롤백되더라도, 그 데이터를 읽고 의존하는 다른 트랜잭션이 없으므로 연쇄적인 롤백이 발생하지 않는다.
*   **남아있는 문제:** 캐스케이드리스 스케줄임에도 불구하고, 여전히 문제가 발생할 수 있다.
    *   예시: H 사장님은 피자 가격을 2만원으로 낮추려 하고(T2), K 직원은 실수로 피자 가격을 1만원으로 낮추려 한다(T1).
    *   현재 피자 가격이 3만원일 때, T1이 피자 가격을 1만원으로 기록한다.
    *   T2가 같은 피자 가격을 2만원으로 덮어쓰고(write) 커밋한다.
    *   이때 T1에 문제가 생겨 롤백되면, 피자 가격은 T1 시작 전의 3만원으로 되돌아간다.
    *   결과적으로 T2가 2만원으로 기록하고 커밋한 결과가 사라지게 된다. 이 스케줄은 T1의 미커밋 데이터를 T2가 읽은 것이 아니므로 캐스케이드리스 스케줄의 정의에는 부합하지만, 원하는 최종 상태는 아니다.

### 4. 스트릭트 스케줄(Strict Schedule)

*   **정의:** 캐스케이드리스 스케줄의 문제를 해결하기 위해, 커밋되지 않은 트랜잭션이 기록한 데이터를 **읽지 않을 뿐만 아니라 쓰지도 않는** 스케줄을 **스트릭트 스케줄**이라고 한다. 즉, 트랜잭션은 이전에 같은 데이터에 기록한 트랜잭션이 완전히 종료(커밋 또는 롤백)될 때까지 해당 데이터를 읽거나 쓰지 않는 스케줄이다. 가장 엄격한 스케줄이다.
*   **동작 방식:** 특정 데이터를 읽거나 쓰려는 트랜잭션은 해당 데이터를 이전에 기록한 트랜잭션이 반드시 먼저 종료(커밋 또는 롤백)된 후에만 작업을 수행할 수 있다.
*   **장점:** 스트릭트 스케줄은 롤백 시 회복이 가장 쉽다. 롤백이 발생하면 단순히 해당 트랜잭션 이전 상태로만 돌려놓으면 되며, 다른 트랜잭션의 커밋된 결과가 사라지는 문제도 발생하지 않는다.

---

### 스케줄의 엄격성 계층 정리

*   **언리커버러블 스케줄:** 롤백 시 회복 불가능할 수 있으므로 DBMS에서 허용하지 않는다.
*   **리커버러블 스케줄:** 롤백 시 회복이 가능하므로 DBMS에서 허용한다.
*   **캐스케이드리스 스케줄:** 리커버러블 스케줄 중 캐스케이딩 롤백이 발생하지 않도록 하는 스케줄이다. (커밋되지 않은 트랜잭션이 기록한 데이터를 읽지 않는다).
*   **스트릭트 스케줄:** 캐스케이드리스 스케줄 중에서도 커밋되지 않은 트랜잭션이 기록한 데이터를 **읽지도 쓰지도 않는** 가장 엄격한 스케줄이다.

**결론적으로, Strict Schedule ⊂ Cascadeless Schedule ⊂ Recoverable Schedule**의 관계를 갖는다. 이러한 스케줄 개념들은 데이터베이스 동시성 제어의 핵심 이론이며, 특히 트랜잭션의 **고립성(Isolation)** 속성과 밀접하게 관련된다.

---
데이터베이스 시스템에서 동시성 제어는 성능 향상을 위한 논-시리얼 스케줄의 장점을 활용하면서도, 데이터의 일관성과 무결성을 보장하기 위한 필수적인 메커니즘이다. 이를 위해 컨플릭트, 시리얼라이저빌리티, 그리고 회복성이라는 복잡하지만 체계적인 이론들이 뒷받침된다. 실제 RDBMS에서는 이러한 이론을 바탕으로 동시성 제어 프로토콜과 아이솔레이션 레벨을 통해 효율적이고 안정적인 데이터 관리를 실현한다.