
## 데이터 무결성을 지키는 트랜잭션(ACID)
### 데이터베이스 트랜잭션: 논리적인 작업 단위와 ACID

`트랜잭션(Transaction)`은 SQL에서 **단일한 논리적인 작업 단위**를 의미한다. 어떤 논리적인 목적을 달성하기 위해 여러 SQL 문들을 하나의 단위로 묶어 처리하며, 이 작업 단위 내의 **모든 SQL 문이 모두 성공해야만 데이터베이스에 반영되고, 일부만 성공해서는 반영되지 않는다**. 이는 마치 아무 일도 일어나지 않았던 것처럼 동작해야 함을 의미한다.

**트랜잭션의 필요성 (예: 계좌 이체)**

계좌 이체 작업은 '한 계좌에서 돈을 빼는 것'과 '다른 계좌에 돈을 넣는 것'이라는 두 개의 SQL UPDATE 문으로 구성된다. 이 두 작업은 논리적으로 하나의 단위로 묶여야 한다. 만약 한쪽만 성공하고 다른 한쪽이 실패한다면, 돈이 갑자기 생기거나 사라지는 비정상적인 데이터 상태가 발생한다. 따라서 이 두 UPDATE 문은 반드시 트랜잭션으로 묶어서 처리해야 한다. 둘 다 성공하거나, 둘 다 실패해서 이전 상태로 돌아가야 한다.

**트랜잭션 사용 방법**

*   **시작:** `START TRANSACTION` 명령어로 트랜잭션의 시작을 알린다.
*   **실행:** 일련의 SQL 문과 관련 로직들을 실행한다.
*   **완료 (성공 시):** 모든 작업이 성공적으로 완료되면 `COMMIT` 명령어로 변경 내용을 데이터베이스에 **영구적으로 저장**한다. COMMIT은 트랜잭션을 종료한다.
*   **취소 (실패 시):** 작업 도중에 문제가 발생했다면 `ROLLBACK` 명령어로 지금까지의 작업을 **모두 취소하고 트랜잭션 시작 이전 상태로 되돌린다**. ROLLBACK도 트랜잭션을 종료한다.

**Auto-Commit**

`Auto-Commit`은 각각의 SQL 문을 자동으로 트랜잭션 처리하는 개념이다. SQL 문이 성공하면 자동으로 커밋하고, 실행 중 문제가 발생하면 자동으로 롤백한다. MySQL에서는 기본적으로 Auto-Commit이 활성화되어 있다. `START TRANSACTION`을 실행하면 Auto-Commit은 비활성화된다. 트랜잭션이 COMMIT이나 ROLLBACK으로 종료되면 Auto-Commit은 원래 상태로 돌아온다.

실제 개발에서는 프로그래밍 언어(예: Java)로 트랜잭션 명령어를 작성한다. DB 연결의 Auto-Commit 설정을 끄고, 작업 성공 시 `commit()`을 호출하며, 예외 발생 시 `rollback()`을 호출하는 식으로 구현한다. 스프링과 같은 프레임워크는 `@Transactional` 어노테이션 등을 통해 트랜잭션 관련 부가 코드를 숨기고 비즈니스 로직만 작성할 수 있도록 돕는다.

**트랜잭션의 핵심 속성: ACID**

트랜잭션은 **ACID**라는 네 가지 중요한 속성을 반드시 지녀야 한다. ACID는 **Atomicity, Consistency, Isolation, Durability**의 앞글자를 딴 것이다.

1.  **Atomicity (원자성):** 트랜잭션 내의 모든 작업은 **모두 성공하거나 아니면 아예 아무 일도 일어나지 않았던 것처럼 모두 실패**해야 한다 (`All or Nothing`). 논리적으로 더 이상 쪼개질 수 없는 작업 단위이기 때문에 내부의 모든 SQL 문이 성공해야 하며, 중간에 실패하면 지금까지의 작업을 모두 취소하고 트랜잭션 시작 이전 상태로 롤백해야 한다. DBMS는 커밋 시 영구 저장과 롤백 시 이전 상태 복원을 담당하고, 개발자는 트랜잭션 단위를 정의하고 커밋/롤백 시점을 결정한다.
2.  **Consistency (일관성):** 트랜잭션 수행 후에도 데이터베이스는 **정의된 규칙에 위배되지 않는 일관된 상태**를 유지해야 한다. 트랜잭션은 일관된 상태에서 또 다른 일관된 상태로 DB를 변환해야 하며, 제약 조건(Constraint)이나 트리거를 통해 정의된 DB의 룰을 위반하면 롤백해야 한다. DBMS는 커밋 전에 룰 위반 여부를 확인하지만, DB에 정의된 룰 외에 애플리케이션 관점에서 일관성을 지키도록 트랜잭션을 정의하고 구현하는 것은 개발자의 역할이다.
3.  **Isolation (격리성/고립성):** 여러 트랜잭션이 동시에 실행될 때도 각 트랜잭션은 **마치 혼자 실행되는 것처럼 동작**해야 하며, 다른 트랜잭션의 중간 결과에 영향을 받거나 서로 간섭해서는 안 된다. 동시 실행 시 발생할 수 있는 예상치 못한 문제(예: Lost Update)를 방지한다. 엄격하게 구현할수록 DB 서버의 성능(동시성)이 저하되기 때문에 DBMS는 여러 종류의 격리 수준(Isolation Level)을 제공한다. 격리 수준이 높을수록 다른 트랜잭션의 영향을 덜 받지만 동시성이 떨어지고, 낮을수록 동시성은 높지만 이상 결과 발생 가능성이 커진다. 개발자는 상황에 맞는 격리 수준을 설정해야 한다.
4.  **Durability (영속성/지속성):** 한번 **커밋된 트랜잭션의 결과는 시스템에 장애(예: 전원 차단, DB 크래시)가 발생하더라도 사라지지 않고 데이터베이스에 영구적으로 저장**되어야 한다. 영구적 저장은 일반적으로 비휘발성 메모리(하드디스크, SSD)에 저장됨을 의미한다. 트랜잭션의 영속성은 기본적으로 DBMS가 보장한다.

트랜잭션을 어떻게 정의하고 사용할지는 개발자가 결정해야 한다. 구현하려는 기능과 트랜잭션의 ACID 속성을 제대로 이해하는 것이 중요하다. DBMS가 모든 것을 자동으로 처리하는 것은 아니며, 개발자가 관리해야 하는 부분들이 있다.

결론적으로 SQL 트리거는 데이터 변경이라는 특정 이벤트에 반응하여 자동화된 액션을 수행하는 메커니즘이고, 트랜잭션은 데이터 변경 작업들을 하나의 논리적 단위로 묶어 ACID 속성을 보장함으로써 데이터의 무결성과 일관성을 유지하는 중요한 개념이다. 이 둘을 올바르게 이해하고 사용하는 것이 안정적인 데이터베이스 시스템을 구축하고 운영하는 데 필수적이다.