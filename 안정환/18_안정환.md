### **락(Lock) 기반 동시성 제어**

데이터의 일관성을 보장하기 위해 가장 널리 사용되는 방법은 **락(Lock)**을 이용하는 것입니다.

### **📍 락의 종류 및 호환성**

- **쓰기 락 (Write Lock / Exclusive Lock, X-Lock)**: 데이터를 변경할 때 사용. 이 락이 걸리면 다른 어떤 트랜잭션도 읽거나 쓸 수 없습니다.
- **읽기 락 (Read Lock / Shared Lock, S-Lock)**: 데이터를 읽을 때 사용. 여러 트랜잭션이 동시에 읽기 락을 걸 수는 있지만, 쓰기 락은 걸 수 없습니다.

| **요청 락 →** | **Read (S)** | **Write (X)** |
| ------------- | ------------ | ------------- |
| **보유 락**   |              |               |
| **Read (S)**  | O (호환)     | X (대기)      |
| **Write (X)** | X (대기)     | X (대기)      |

### **📍 2단계 잠금 프로토콜 (Two-Phase Locking, 2PL)**

락을 사용하더라도 순서를 제어하지 않으면 직렬성을 위반할 수 있습니다. **2PL**은 직렬성을 보장하기 위한 대표적인 락 사용 규칙입니다.

- **정의**: 트랜잭션 내에서 **한번 언락(Unlock)이 시작되면, 그 이후에는 새로운 락(Lock)을 획득할 수 없다**는 규칙입니다.
- **2PL의 두 단계**
  1. **확장 단계 (Expanding Phase)**: 새로운 락을 계속해서 획득할 수 있는 단계.
  2. **축소 단계 (Shrinking Phase)**: 보유한 락을 해제하기 시작하는 단계. 이 단계에 진입하면 더 이상 새로운 락을 획득할 수 없습니다.

> ⚠️ 2PL의 문제점: 2PL은 직렬성을 보장하지만, 락을 서로 기다리는 과정에서 **데드락(Deadlock)**이 발생할 수 있습니다. 데드락이란 두 개 이상의 트랜잭션이 서로가 점유한 자원의 해제를 기다리며 모든 작업이 멈춰버리는 교착 상태를 의미합니다.

### **📍 2PL의 종류**

- **Conservative 2PL**: 트랜잭션 시작 전에 필요한 모든 락을 한 번에 획득합니다. 데드락은 발생하지 않지만 실용성이 떨어집니다.
- **Strict 2PL (S2PL)**: **가장 널리 사용됩니다.** 획득한 **쓰기 락(X-Lock)**은 트랜잭션이 **커밋되거나 롤백될 때까지** 절대 해제하지 않습니다. 이는 **Strict Schedule**을 보장하여 회복 가능성을 높입니다.
- **Strong Strict 2PL (Rigorous 2PL)**: **쓰기 락**뿐만 아니라 **읽기 락(S-Lock)** 또한 트랜잭션이 종료될 때까지 해제하지 않습니다. 구현이 단순하지만 동시성 수준은 S2PL보다 낮을 수 있습니다.
