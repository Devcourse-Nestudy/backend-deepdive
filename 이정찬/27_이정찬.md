### DBCP (Database Connection Pool)

우리가 백엔드 서버를 만들고 데이터베이스(DB)에 데이터를 조회하거나 저장할 때, 그 과정이 얼마나 복잡한지 모를 때가 많다. 그냥 쿼리 보내면 DB가 알아서 처리해 주는 줄 아는 경우가 흔하다. 하지만 그 이면에는 생각보다 많은 일이 벌어진다.

#### 1. DB 접근, 왜 느려 터지는가?

백엔드 서버와 DB 서버는 보통 서로 다른 컴퓨터에서 돌아간다. 그래서 이 둘이 데이터를 주고받을 때는 **네트워크 통신**을 한다. 이때 주로 **TCP**라는 방식을 사용하는데, 얘가 좀 까다로운 특징을 가지고 있다.

- **연결 지향적 특징**: TCP는 본격적으로 데이터를 주고받기 전에 **반드시 연결을 맺는 과정(커넥션)**이 필요하다. 그리고 다 쓰고 나면 **연결을 끊는 과정**도 필요하다.
- **시간 소모**: 문제는 이 **커넥션을 열고 닫는 과정이 꽤 시간을 잡아먹는다**는 점이다. 마치 전화를 걸고 받을 때 "여보세요?", "네, 안녕하세요." 하고 대화 준비하는 과정과 같다고 보면 된다. "쓰리웨이 핸드셰이크", "포웨이 핸드셰이크" 같은 복잡한 절차를 거쳐야 한다.
- **성능 저하**: 백엔드 서버는 API 요청을 엄청나게 많이 받지 않는가? 그 요청마다 DB에 접근해야 하는데, 그때마다 매번 커넥션을 열고 닫고 한다면, 그 시간적 비용이 계속 쌓여 **결국 API 응답 시간이 길어지고 서비스 성능이 나빠진다**.

이런 비효율적인 상황을 해결하기 위해 등장한 것이 바로 **DBCP (Database Connection Pool)** 가 된다.

#### 2. DBCP, 그 작동 원리는 무엇인가?

DBCP는 이 문제에 대한 아주 똑똑한 해결책이 된다.

- **미리 연결 맺기**: 어플리케이션 서버를 처음 띄울 때, 그러니까 API 요청을 받기 전에 **미리 DB 커넥션들을 왕창 만들어 둔다**.
- **풀(Pool)에 보관**: 이렇게 만들어진 커넥션들을 마치 **수영장(풀)**처럼 한곳에 모아 관리한다.
- **커넥션 재사용**: 이제 API 요청이 들어와 DB에 접근할 일이 생기면, **새로 커넥션을 만들지 않고 풀 안에 있는 놀고 있는(아이들) 커넥션을 하나 빌려 쓴다**.
- **반납 (닫는 게 아니다!)**: 쿼리 처리가 끝나면, 빌려 썼던 커넥션을 **다시 풀에 반납한다**. 이때 `close()`라는 명령어를 쓰기도 하지만, 실제로 커넥션을 끊는 것이 아니라 **다음에 재사용할 수 있도록 풀로 돌려놓는 것**이 된다.

이렇게 되면 커넥션을 열고 닫는 시간을 아낄 수 있어 **API 응답 시간이 단축되고, 백엔드 서버의 전체적인 성능이 향상된다**. 결국, 커넥션을 미리 맺어놓고 풀로 만들어 재사용하는 방식, 이것이 바로 **데이터베이스 커넥션 풀(DBCP)**이 되는 것이다.

```markdown
[DBCP 작동 흐름 시각화]

초기 앱 실행 시:
┌───────────────────┐ ┌───────────────────────┐
│ 백엔드 서버 │ │ DB 서버 │
│ │ │ │
│ 1. 미리 DB 연결 맺기 ┼───────▶ TCP 커넥션 1 │
│ 2. 커넥션 풀 생성 ┼───────▶ TCP 커넥션 2 │
│ (ex: 커넥션 3개) ┼───────▶ TCP 커넥션 3 │
└───────────────────┘ └───────────────────────┘
▲ DB 커넥션 풀 (초기 상태: 모두 Idle)
│ (C1) (C2) (C3)
└───────────────────┘

API 요청 처리 시:
┌───────────────────┐ ┌───────────────────────┐
│ 백엔드 서버 │ │ DB 서버 │
│ │ │ │
│ 3. 요청 처리 중 DB 접근 ◀──────────┐ │
│ (C1) 빌려오기 │ │
│ │ │
└───────────────────┘ └───────────────────────┘
▲ DB 커넥션 풀 (C1은 In-Use, C2, C3는 Idle)
│ (C1_InUse) (C2) (C3)
└───────────────────┘

쿼리 처리 후:
┌───────────────────┐ ┌───────────────────────┐
│ 백엔드 서버 │ │ DB 서버 │
│ │ │ │
│ 4. 쿼리 응답 수신 ◀───────────┐ │
│ 5. (C1) 풀에 반납 ┼───────────┘ │
└───────────────────┘ └───────────────────────┘
▲ DB 커넥션 풀 (다시 모두 Idle)
│ (C1) (C2) (C3)
└───────────────────┘
```

#### 3. DBCP 설정, 놓치지 말아야 할 파라미터들

DBCP를 제대로 활용하려면 DB 서버와 백엔드 서버 양쪽에서 설정을 잘 해줘야 한다. MySQL과 히카리CP(HikariCP)를 예시로 들어보겠다.

**3.1 MySQL DB 서버 설정**

- **`max_connections` (최대 커넥션 수)**:

  - **DB 서버가 클라이언트(백엔드 서버 등)와 맺을 수 있는 최대 커넥션 수를 의미한다**.
  - 예를 들어, `max_connections`가 4인데 백엔드 서버가 이미 4개의 커넥션을 맺고 있다면, 새로운 백엔드 서버를 추가하려 해도 DB에 연결할 수 없게 된다.
  - 이 값을 너무 작게 잡으면, 백엔드 서버를 추가하거나 DBCP 커넥션 수를 늘리려 할 때 문제가 발생하니 **충분히 적절한 값으로 설정해야 한다**.

- **`wait_timeout` (유휴 커넥션 대기 시간)**:
  - **DB 서버에서 아무것도 하지 않고 놀고 있는 커넥션이 다시 요청을 받기까지 얼마의 시간을 기다리다가 끊어버릴지 결정하는 파라미터가 된다**.
  - 커넥션이 비정상적으로 종료되거나, 백엔드에서 커넥션을 빌려갔다가 반납하지 않는 버그가 생기면, 그 커넥션이 DB 서버 리소스를 계속 점유할 수 있다. 이런 이상한 상태의 커넥션을 적절한 시점에 정리해서 **DB 서버의 리소스 누수를 막는 데 사용된다**.
  - 만약 이 타임아웃 시간 안에 새로운 요청이 들어오면, 타임아웃은 다시 초기화된다.

**3.2 히카리CP (백엔드 서버) 설정**

- **`minimum-idle` (최소 유휴 커넥션 수)**:

  - **커넥션 풀에서 최소한으로 유지할 유휴(놀고 있는) 커넥션 수를 의미한다**.
  - 얘보다 유휴 커넥션 수가 적어지면, 풀은 새 커넥션을 만들려고 한다.

- **`maximum-pool-size` (최대 풀 사이즈)**:

  - **커넥션 풀이 가질 수 있는 최대 커넥션 수(유휴 + 사용 중인 커넥션 모두 포함)를 의미한다**.
  - 이 파라미터는 `minimum-idle`보다 **우선순위가 높다**. 아무리 `minimum-idle`보다 유휴 커넥션이 적더라도, `maximum-pool-size`에 도달하면 더 이상 새 커넥션을 만들지 않는다.
  - **권장 사항**: 히카리CP는 `minimum-idle`을 `maximum-pool-size`와 **동일하게 설정**하도록 권장한다. 이는 풀 사이즈를 고정으로 유지하여, 트래픽이 몰려올 때 커넥션 생성 지연으로 인한 성능 저하를 막기 위함이 된다.

- **`max-lifetime` (커넥션 최대 수명)**:

  - **풀에서 커넥션의 최대 수명을 의미한다**. 이 시간을 넘어서면 커넥션은 제거된다.
  - **제거 시점**: 유휴 커넥션이면 바로 제거되고, 사용 중인 커넥션이면 풀에 반환된 후에 제거된다.
  - **중요**: 만약 커넥션이 풀에 **반환되지 않는다면**, 이 `max-lifetime`은 동작하지 않아 해당 커넥션은 계속 살아있게 된다. 이는 **커넥션 누수**로 이어져 나중에 익셉션이 발생할 수 있다.
  - **핵심 주의사항**: 이 `max-lifetime`은 **DB 서버의 `wait_timeout`보다 짧게 설정**해야 한다 (2~5초 정도). 그렇지 않으면 백엔드에서 커넥션을 사용하고 있는 도중에 DB 서버가 `wait_timeout`으로 커넥션을 끊어버려 문제가 발생할 수 있다.

  ```markdown
  [max-lifetime vs wait_timeout 시각화]

  잘못된 설정 (max-lifetime = wait_timeout):
  DB 서버 (wait_timeout=60초) <--- 커넥션 ---▶ 백엔드 서버 (max-lifetime=60초)

  시간 흐름:
  T=0s: 커넥션 생성
  T=59s: 백엔드에서 커넥션 빌려 DB 쿼리 전송 시작
  T=60s: DB 서버에서 wait_timeout 발동, 커넥션 끊김 (쿼리 처리 중)
  백엔드 서버의 쿼리 요청은 DB에 도달하지 못하고 실패 (Exception 발생)

  올바른 설정 (max-lifetime < wait_timeout):
  DB 서버 (wait_timeout=60초) <--- 커넥션 ---▶ 백엔드 서버 (max-lifetime=55초)

  시간 흐름:
  T=0s: 커넥션 생성
  T=54s: 백엔드에서 커넥션 빌려 DB 쿼리 전송 시작
  T=55s: 백엔드에서 max-lifetime 도달 감지, 쿼리 처리 완료 후 커넥션 제거 및 새 커넥션 생성
  (DB 서버의 wait_timeout은 아직 5초 남음)
  → DB 서버가 먼저 끊기기 전에 백엔드에서 커넥션을 안전하게 교체할 수 있다.
  ```

- **`connection-timeout` (커넥션 대기 시간)**:
  - **DBCP에서 커넥션을 빌려오기 위해 기다리는 최대 시간을 의미한다**.
  - 이 시간 안에 커넥션을 받지 못하면 익셉션을 발생시킨다.
  - 사용자 경험을 고려하여 적절한 값을 설정해야 한다. 사용자는 30초씩 기다리지 않기 때문에, 너무 길게 잡으면 무의미할 수 있다.

#### 4. 적절한 커넥션 수, 어떻게 찾으면 되는가? (부하 테스트)

DBCP 파라미터는 서비스 규모와 특성에 따라 최적의 값이 달라진다. 가장 좋은 방법은 **부하 테스트**를 통해 직접 찾아보는 것이 된다.

**4.1 테스트 준비**

- **모니터링 환경 구축**: 백엔드 서버와 DB 서버의 CPU, 메모리, 네트워크 사용량 등 **자원 사용률을 실시간으로 확인할 수 있는 모니터링 환경**을 미리 갖춰둬야 한다.
- **레플리케이션 구성**: 일반적으로 DB 서버는 고가용성(HA)을 위해 여러 대로 복제(레플리케이션)해서 사용한다. 쓰기(Write) 요청은 주 서버(프라이머리)가 처리하고, 읽기(Read) 요청은 보조 서버(세컨더리)들이 분산 처리하는 방식이 흔하다.

**4.2 부하 테스트 진행**

- **도구 사용**: 네이버의 NGrinder 같은 부하 테스트 툴을 사용한다.
- **점진적 부하 증가**: 요청 수를 조금씩 늘려가면서 백엔드 시스템이 어떻게 동작하는지 관찰한다.
- **핵심 지표 모니터링**:

  - **RPS (Requests Per Second)**: 초당 처리할 수 있는 요청 수, 즉 시스템의 전체 처리량을 본다. 부하를 늘리면 처음엔 늘다가 어느 순간 더 이상 늘지 않는 지점(포화 상태)이 나타난다.
  - **Average Response Time (평균 응답 시간)**: API 요청에 대한 처리 시간이다. 부하를 늘려도 어느 순간까지는 일정하게 유지되다가, 갑자기 늘어나기 시작하는 지점(성능 저하 시작)이 나타난다.

  ```markdown
  [RPS & Average Response Time 그래프 예시]

  RPS (처리량):
  ▲ 요청 처리량 (RPS)
  │ ／￣￣￣￣￣￣
  │ ／
  │ ／
  └───────────────────▶ 부하 (요청 수)
  (어느 순간부터 처리량 증가가 멈춘다)

  Average Response Time (응답 시간):
  ▲ 평균 응답 시간
  │ ／
  │ ／
  │ ───────
  └───────────────────▶ 부하 (요청 수)
  (어느 순간부터 응답 시간이 급격히 늘어난다)
  ```

**4.3 병목 현상 분석 및 파라미터 조정**

- **서버 자원 확인**:
  - **백엔드 서버 CPU/메모리 과부하**: 만약 백엔드 서버의 CPU나 메모리 사용률이 60~80% 이상으로 치솟는다면, **백엔드 서버를 추가**하여 트래픽을 분산시켜야 한다.
  - **DB 서버 CPU/메모리 과부하**: DB 서버의 자원 사용률이 높다면, **세컨더리 서버를 추가**(읽기 요청이 많을 경우), **캐시 레이어 도입**, **샤딩** 등의 방법을 고려해 DB 부하를 낮춰야 한다.
- **자원은 괜찮은데 성능이 꺾인다면?**
  - **쓰레드 풀 확인**: 쓰레드-퍼-리퀘스트(Thread-per-Request) 모델이라면, 요청 처리에 사용되는 **쓰레드 풀의 쓰레드 수가 병목 현상일 수 있다**. 만약 쓰레드 풀의 모든 쓰레드가 사용 중이라면, **쓰레드 풀 크기를 늘려야 한다**.
  - **DBCP 액티브 커넥션 수 확인**: 만약 DBCP의 `maximum-pool-size`에 해당하는 모든 커넥션이 사용 중이라면, **`maximum-pool-size` 값을 늘려서 테스트**해 본다.
    - `maximum-pool-size`를 5에서 10, 15... 이런 식으로 계속 늘려가면서 부하 테스트를 반복한다.
    - **주의**: DBCP `maximum-pool-size`의 총합이 DB 서버의 `max_connections`를 넘지 않도록 해야 한다. 만약 `max_connections`에 도달했는데도 여전히 성능 개선 여지가 있다면, DB 서버의 `max_connections` 자체를 늘려야 한다.
- **최적값 결정**: 이렇게 부하 테스트를 반복하면서 **DB 서버의 `max_connections`**와 **각 백엔드 서버의 DBCP `maximum-pool-size`**를 적절하게 결정한다. 이 과정에서 미래의 트래픽 증가나 예비 서버 투입 등 여러 요소를 종합적으로 고려하면 된다.

**4.4 기타 참고사항**

- 실제 운영 중인 서버에 부하 테스트를 할 때는 사용자에게 영향을 주지 않도록 **트래픽이 적은 시간대에 진행**하는 것이 좋다.
- DBCP 종류는 다양하다 (히카리CP 외에 Commons DBCP 등). 현재 서비스에서 사용하는 DBCP의 사용법을 정확히 숙지하는 것이 중요하다.

---
