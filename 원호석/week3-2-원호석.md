# Database Indexing

## 1. 인덱스
데이터베이스에서 검색 속도를 향상시키기 위한 자료 구조

## 2. 인덱스의 동작 원리
인덱스는 기본 테이블의 데이터를 정렬된 방식으로 복사. \n
일반적으로 B-Tree나 Hash를 기반으로 하며, 검색 시 인덱스를 먼저 조회한 후 해당 레코드의 주소를 따라가 데이터를 찾는다.

## 3. 인덱스의 장점
- **조회 성능 향상**: WHERE, JOIN, ORDER BY, GROUP BY 절에서 빠른 탐색 가능
- **중복 방지**: UNIQUE 제약조건 구현 시 사용
- **정렬 비용 절감**: 이미 정렬된 인덱스를 활용할 수 있음

## 4. 인덱스의 단점
- **쓰기 성능 저하**: INSERT, UPDATE, DELETE 시 인덱스도 같이 수정되어야 함
- **저장 공간 증가**: 별도의 자료 구조가 필요함
- **과도한 인덱스는 오히려 성능 저하**: 쿼리 최적화 실패 가능성 증가

## 5. 인덱스의 종류
### 5.1 기본 인덱스 유형
- **B-Tree 인덱스**: 가장 일반적인 인덱스, 정렬 기반 검색에 적합
- **Hash 인덱스**: 정확한 값 비교에 빠르지만 범위 검색 불가 (주로 메모리 기반 DB에서 사용)
- **Bitmap 인덱스**: 값의 종류가 적은 컬럼에 효과적 (ex. 성별, 국가 등)

### 5.2 구성 방식에 따른 분류
- **단일 컬럼 인덱스**: 하나의 컬럼에만 인덱스를 생성
- **복합 인덱스(Composite Index)**: 여러 컬럼을 하나의 인덱스로 구성 (선두 컬럼 규칙 주의)

### 5.3 생성 방식
- **Primary Key 인덱스**: 기본 키에 자동 생성
- **Unique 인덱스**: 중복을 허용하지 않는 인덱스
- **Full-Text 인덱스**: 전체 텍스트 검색을 위한 인덱스 (MySQL의 InnoDB 등에서 지원)

## 6. 인덱스 설계 시 고려사항
- 자주 사용하는 **WHERE, JOIN, ORDER BY** 절의 컬럼에 인덱스를 고려
- **데이터의 분포도**가 높을수록 인덱스 효율성 증가 (분포도: 데이터의 값이 다양한 정도)
- **업데이트가 빈번한 테이블**에는 최소한의 인덱스만 유지
- **복합 인덱스는 선두 컬럼부터 사용해야 효율적** (Left-most prefix rule)
- **커버링 인덱스(Covering Index)** 활용 시, 쿼리가 인덱스만으로 처리 가능

## 7. 인덱스 확인 및 관리
- **MySQL**:
  - 인덱스 확인: `SHOW INDEX FROM table_name;`
  - 인덱스 생성: `CREATE INDEX idx_name ON table(col);`
  - 인덱스 삭제: `DROP INDEX idx_name ON table;`

- **PostgreSQL**:
  - 인덱스 확인: `\d table_name`
  - 인덱스 생성: `CREATE INDEX idx_name ON table(col);`
  - 인덱스 삭제: `DROP INDEX idx_name;`

## 8. 결론
인덱스는 데이터베이스의 성능 최적화에 필수적인 요소입니다. 그러나 무분별한 인덱스 생성은 오히려 성능을 저하시킬 수 있으므로, 쿼리 패턴과 데이터 특성을 고려하여 신중히 설계해야 합니다.