## 데이터베이스 정규화 과정: 1NF와 2NF 상세 분석

데이터베이스 정규화(Normalization)는 데이터 중복과 삽입(Insertion), 갱신(Update), 삭제(Deletion) 이상(Anomaly)을 최소화하기 위해 릴레이션(테이블)을 일련의 노멀 폼(Normal Form)에 따라 구성하는 과정이다. 노멀 폼은 정규화되기 위해 준수해야 하는 특정 규칙들을 의미한다. 정규화 과정은 초기 테이블부터 1NF, 2NF, 3NF 등 각 노멀 폼을 순차적으로 적용하며 진행되며, 앞 단계를 만족해야 다음 단계로 넘어갈 수 있다. 따라서 만약 어떤 테이블이 3NF를 만족한다면, 해당 테이블은 이미 1NF와 2NF도 만족하고 있는 것이다. 일반적으로 3NF까지 도달하면 테이블이 정규화되었다고 말하며, 실무에서는 주로 3NF 또는 BCNF까지 진행된다.

### 예제 테이블 및 핵심 개념 이해

정규화 과정을 설명하기 위해 임직원의 월급 계좌 정보를 관리하는 가상의 테이블을 사용한다. 이 테이블은 다음과 같은 정보를 포함한다:

- **은행 이름 (Bank Name):** 국민은행 또는 우리은행.
- **계좌 번호 (Account Number):** 각 은행 내에서 유니크하다.
- **계좌 ID (Account ID):** 각 계좌를 식별하기 위해 부여된 ID로, 테이블의 튜플(행)을 유니크하게 식별할 수 있는 속성이다.
- **등급 (Class):** 계좌 등급 (국민은행: 스타, 프레스티지, 로얄; 우리은행: 브론즈, 실버, 골드).
- **비율 (Ratio):** 월급 분배 비율 (각 계좌에 월급이 어떤 비율로 분배될지 저장).
- **임직원 ID (Employee ID):** 임직원 식별자.
- **임직원 이름 (Employee Name):** 임직원 이름.
- **카드 ID (Card ID):** 계좌와 연동된 현금 카드 ID. 하나의 계좌는 하나 이상의 현금 카드와 연동될 수 있다.

이 테이블을 이해하기 위해 몇 가지 데이터베이스 핵심 개념을 먼저 살펴본다:

- **슈퍼키 (Superkey):** 테이블에서 튜플들을 유니크하게 식별할 수 있는 애트리뷰트(속성)들의 집합이다.
- **후보키 (Candidate Key):** 슈퍼키 중에서 어느 하나의 애트리뷰트라도 제거하면 더 이상 유니크하게 튜플을 식별할 수 없는 최소한의 슈퍼키를 의미한다.
  - 예제 테이블에서 `Account ID`는 단일 애트리뷰트로 튜플을 유니크하게 식별하므로 후보키가 될 수 있다.
  - `(Bank Name, Account Number)`는 다른 은행에서 계좌번호가 겹칠 수 있으므로 함께 사용될 때 튜플을 유니크하게 식별할 수 있어 또 다른 후보키가 될 수 있다.
- **기본키 (Primary Key, PK):** 테이블에서 튜플들을 유니크하게 식별하기 위해 선택된 후보키이다. 예제에서는 속성 수가 적어 관리가 편한 **`Account ID`를 기본키로 선택**하였다. 기본키는 일반적으로 밑줄로 표시된다.
- **프라임 애트리뷰트 (Prime Attribute):** 어떤 후보키에라도 속하는 애트리뷰트를 의미한다. 예제에서는 `Account ID`, `Bank Name`, `Account Number`가 프라임 애트리뷰트이다.
- **논-프라임 애트리뷰트 (Non-Prime Attribute):** 프라임 애트리뷰트가 아닌 모든 애트리뷰트, 즉 어떤 키에도 속하지 않는 애트리뷰트들을 말한다. 예제에서는 `Class`, `Ratio`, `Employee ID`, `Employee Name`, `Card ID`가 논-프라임 애트리뷰트이다.

또한, 예제 테이블에 존재하는 주요 **함수적 종속(Functional Dependency, FD)**들을 파악하는 것이 중요하다:

- **`Account ID` -> 모든 다른 애트리뷰트:** 기본키인 `Account ID`는 테이블 내의 다른 모든 애트리뷰트의 값을 유니크하게 결정한다.
- **`(Bank Name, Account Number)` -> 모든 다른 애트리뷰트:** 또 다른 후보키인 `(Bank Name, Account Number)`도 테이블 내의 다른 모든 애트리뷰트의 값을 유니크하게 결정한다.
- **`Employee ID` -> `Employee Name`:** 임직원 ID가 같으면 임직원 이름도 같을 것이므로 `Employee ID`가 `Employee Name`을 결정한다.
- **`Class` -> `Bank Name`:** 국민은행과 우리은행의 등급 이름이 서로 겹치지 않으므로, 등급(`Class`)만 보더라도 해당 계좌가 어느 은행의 계좌인지 알 수 있다. 즉, `Class`가 `Bank Name`을 결정한다.

### 1차 정규형 (First Normal Form, 1NF)

**1NF의 규칙은 모든 애트리뷰트의 값이 반드시 나누어질 수 없는 단일한 값을 가져야 한다는 것이다**. 즉, 각 셀에 하나의 값만 존재해야 하며, 여러 값을 포함하는 복합 값이나 반복 그룹이 없어야 한다.

예제 테이블의 초기 상태를 보면 `Card ID` 애트리뷰트에서 이 1NF 규칙을 위반하는 경우가 있다. 예를 들어, `Card ID`가 "123, 456"과 같이 두 개의 카드 번호를 하나의 셀에 저장하고 있을 수 있다. 이는 단일한 값이 아니므로 1NF를 위반한다.

**1NF 위반을 해결하는 방법**은 여러 가지가 있지만, 가장 단순하게는 **해당 값을 쪼개어 별도의 튜플로 만드는 것이다**. 예를 들어, `Card ID`가 "123, 456"인 튜플이 있다면, 이를 "123"을 가진 튜플 하나와 "456"을 가진 튜플 하나로 분리하고, 다른 애트리뷰트들은 중복하여 저장한다.

그러나 이 1NF 변환 과정에서 다음과 같은 문제들이 발생한다:

- **데이터 중복 발생:** `Card ID`를 쪼개면서 다른 모든 애트리뷰트의 값이 중복되어 저장된다. 예를 들어, 같은 계좌 정보가 여러 개의 `Card ID` 값에 따라 여러 튜플로 복제된다.
- **`Ratio` 값의 의미 왜곡:** 만약 `Ratio`가 월급 분배 비율의 합이 1이 되어야 하는 개념이라면, 중복된 튜플들로 인해 `Ratio`의 합이 1을 초과하는 등 원래 의도와 다른 값이 될 수 있다.
- **기본키 변경:** 기존의 기본키였던 `Account ID`는 이제 더 이상 유니크하게 튜플을 식별할 수 없게 된다. 동일한 `Account ID`를 가진 튜플이 `Card ID`에 따라 여러 개 존재하기 때문이다. 따라서 **새로운 기본키는 `(Account ID, Card ID)`와 같은 복합키로 변경되어야 한다**. 다른 후보키 또한 `(Bank Name, Account Number, Card ID)`와 같이 `Card ID`가 포함된 복합키가 된다.

결과적으로, 1NF를 만족하는 테이블은 데이터 중복이라는 새로운 문제를 안게 된다.

### 2차 정규형 (Second Normal Form, 2NF)

1NF를 만족하는 테이블에서 발생한 데이터 중복의 원인을 분석하면 2NF의 필요성을 이해할 수 있다. 1NF 변환으로 인해 기본키가 `(Account ID, Card ID)`와 같은 복합키가 되었고, 다른 후보키 또한 `(Bank Name, Account Number, Card ID)`처럼 복합키가 되었다.

**2NF 위반의 핵심 원인은 논-프라임 애트리뷰트들이 후보키 전체에 대해 완전 함수적 종속(Full Functional Dependency)이 아니라, 후보키의 일부에 대해서만 종속되는 부분 함수적 종속(Partial Functional Dependency)이 존재하기 때문이다**.

예를 들어, `Class`, `Ratio`, `Employee ID`, `Employee Name`과 같은 논-프라임 애트리뷰트들은 기본키인 `(Account ID, Card ID)` 전체에 종속되는 것이 아니라, `Account ID` 하나만으로도 유니크하게 결정될 수 있다. 즉, `Account ID`만으로도 해당 계좌의 `Class`, `Ratio` 등이 결정된다는 의미이다. 그럼에도 불구하고 `Card ID`가 키에 포함되어 있기 때문에 `Card ID`가 달라지면 이 논-프라임 애트리뷰트들이 불필요하게 중복되는 현상이 발생한다. 다른 후보키인 `(Bank Name, Account Number, Card ID)`의 경우도 마찬가지로, `(Bank Name, Account Number)`만으로도 논-프라임 애트리뷰트들이 결정되는데 `Card ID`가 키에 포함되어 중복을 야기한다.

**2NF의 규칙은 모든 논-프라임 애트리뷰트가 모든 후보키에 대해 완전 함수적 종속이어야 한다는 것이다**. 즉, 논-프라임 애트리뷰트가 어떤 후보키의 부분집합에도 부분적으로 종속되어서는 안 된다.

이 문제를 해결하기 위해 **테이블을 분해(Decomposition)한다**. 문제의 원인이었던 `Card ID`를 원래 테이블에서 분리하여 새로운 테이블로 만드는 것이다.

**2NF 변환 과정:**

1.  **`Card ID` 애트리뷰트를 분리한다.** 이때 원래 테이블과의 연결 고리를 유지하기 위해 `Account ID`를 함께 새로운 테이블에 포함시킨다.
    - 새로운 테이블: `(Account ID, Card ID)`. 이 테이블의 기본키는 `(Account ID, Card ID)`가 된다.
2.  **원래 테이블에서 `Card ID` 애트리뷰트를 삭제한다**.
3.  **원래 테이블에서 중복된 튜플들을 제거한다**. 1NF 변환으로 인해 생겼던 동일한 튜플들을 하나로 합치는 것이다.

**2NF 변환 결과:**

- **원래 테이블:** 이제 `Card ID`가 제거되었고, 기본키는 다시 `Account ID`가 된다. 이 테이블의 논-프라임 애트리뷰트들은 `Account ID` (또는 `(Bank Name, Account Number)`)에 대해 완전 함수적 종속을 만족한다. 더 이상 부분 종속이 없으므로 데이터 중복이 해결된다.
- **새로운 테이블:** `(Account ID, Card ID)` 테이블은 `Card ID`가 `(Account ID, Card ID)`에 대해 완전 함수적 종속을 만족한다.

이렇게 테이블을 두 개로 분리함으로써 두 테이블 모두 2NF를 만족하게 되며, 데이터 중복 문제가 효과적으로 해결된다.
