## 트랜잭션 동시성 제어 핵심: 스케줄과 직렬성(Serializability) 

데이터베이스를 다루는 개발자라면 트랜잭션(Transaction)의 중요성을 익히 알고 있다. 특히 여러 트랜잭션이 동시에 실행될 때 발생하는 복잡한 문제들을 이해하고 해결하는 것은 안정적인 시스템 구축에 필수적이다. 

### 1. 트랜잭션 동시 실행과 스케줄의 탄생

우리는 K가 H에게 20만원을 이체하고, 동시에 H가 자신의 계좌에 30만원을 입금하는 상황을 예시로 들어 본다. 이런 동시 발생 상황에서는 여러 가지 실행 순서가 가능하다.
```
# case1(직렬 스케쥴)
T1 (20만원 이체)          T2 (30만원 입금)
-----------------------------------------------
1. R1(K)                  |
2. W1(K)                  |
3. R1(H)                  |
4. W1(H)                  |
5. C1                     |
                          |
6.                        R2(H)
7.                        W2(H)
8.                        C2
```
```
# case2(비직렬 스케쥴쥴)
T1 (20만원 이체)          T2 (30만원 입금)
-----------------------------------------------
1. R1(K)                  |
2. W1(K)                  |
3.                        R2(H)
4.                        W2(H)
5.                        C2
6. R1(H) (T2가 업데이트한 H 잔액(230만)을 읽음)
7. W1(H) (H 잔액을 250만으로 업데이트)
8. C1                     |
```
```
#case3(로스트 업데이트를 초래하는 비직렬 스케줄)
T1 (20만원 이체)          T2 (30만원 입금)
-----------------------------------------------
1. R1(K)                  |
2. W1(K)                  |
3. R1(H) (H 잔액 200만 읽음)
4.                        R2(H) (H 잔액 200만 읽음)
5.                        W2(H) (H 잔액 230만으로 업데이트)
6.                        C2
7. W1(H) (T2의 변경을 모른 채, 200만 기준 220만으로 H를 덮어씀)
8. C1 
```

   **스케줄(Schedule)이란 무엇인가?**
   *   **스케줄**은 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션에 속한 연산(오퍼레이션)들이 어떻게 실행되는지 그 실행 순서를 의미한다.
   *   각 트랜잭션 내에서 연산의 순서(예: K 읽기 -> K 쓰기 -> H 읽기 -> H 쓰기 -> 커밋)는 어떤 스케줄 형태에서도 바뀌지 않는다.
   *   각각의 실행 순서 예시(스케줄 1, 2, 3, 4 등)는 모두 하나의 스케줄이다.
   *   **오퍼레이션 간소화**: 트랜잭션의 연산은 `R1(K)` (1번 트랜잭션이 K를 읽기), `W1(K)` (1번 트랜잭션이 K에 쓰기), `C2` (2번 트랜잭션 커밋) 등으로 간소화하여 표현할 수 있다.

### 2. 스케줄의 종류와 성능 문제

*   **직렬 스케줄(Serial Schedule)**
    *   **정의**: 두 트랜잭션이 겹치지 않고 한 번에 하나씩 순차적으로 실행되는 스케줄을 의미한다.
    *   **장점**: 이상한 데이터를 만들 가능성이 없으며, 항상 정상적인 결과를 보장한다.
    *   **단점**: 한 번에 하나의 트랜잭션만 실행되므로 **동시성(Concurrency)이 없어 성능이 좋지 않다**. 이는 I/O 작업 중 CPU가 놀게 되더라도 다른 트랜잭션을 실행하지 않기 때문이다. 따라서 현실적으로 사용하기 어렵다.
    *   예시: 스케줄 1, 스케줄 2는 직렬 스케줄에 해당한다.

*   **비직렬 스케줄(Non-Serial Schedule)**
    *   **정의**: 트랜잭션들이 겹쳐서(Interleaving) 실행되는 스케줄을 의미한다.
    *   **장점**: 트랜잭션들이 겹쳐서 실행되므로 **동시성이 높아져 같은 시간 동안 더 많은 트랜잭션들을 처리할 수 있어 성능이 좋아진다**. I/O 작업 중에도 CPU가 다른 트랜잭션을 처리할 수 있기 때문이다.
    *   **단점**: 트랜잭션들이 어떤 형태로 겹쳐서 실행되는지에 따라 **이상한 결과가 나올 수 있다**.
    *   예시: 스케줄 3, 스케줄 4는 비직렬 스케줄에 해당한다.

*   **이상 현상 예시: 로스트 업데이트(Lost Update)**
    *   스케줄 4번은 비직렬 스케줄의 대표적인 이상 현상인 **로스트 업데이트**를 보여준다.
    *   T1이 H 계좌에서 200만원을 읽고, T2가 H 계좌에 30만원을 입금하여 230만원으로 업데이트하고 커밋한다.
    *   이후 T1은 30만원 입금 사실을 모른 채, 이전에 읽었던 200만원을 기준으로 20만원을 더해 220만원으로 H 계좌를 덮어쓴다.
    *   결과적으로 H 계좌에 입금된 30만원이 사라지는 현상(200만 + 30만 + 20만 = 250만 예상, 실제는 220만)이 발생한다.

### 3. 직렬성(Serializability) 개념의 등장: 성능과 정확성의 조화

성능을 위해 비직렬 스케줄을 허용하고 싶지만, 이상한 결과는 피하고 싶다는 고민이 생겨났다. 여기서 **직렬성(Serializability)** 개념이 등장한다.

*   핵심 아이디어는 **비직렬 스케줄을 실행하더라도, 직렬 스케줄과 동일한 결과**를 내는 비직렬 스케줄을 실행하자는 것이다. 직렬 스케줄은 항상 정상적인 결과를 보장하기 때문이다.

### 4. 스케줄 동일성(Equivalence)의 정의: 충돌 동일성(Conflict Equivalence)

스케줄의 동일성을 정의하는 가장 널리 사용되는 방식 중 하나는 `충돌 동일성(Conflict Equivalence)`이다.

*   **충돌(Conflict)의 개념**
    두 개의 연산(오퍼레이션)이 다음 세 가지 조건을 **모두 만족**하면 충돌한다고 본다.
    1.  두 오퍼레이션이 **서로 다른 트랜잭션에 소속**되어야 한다.
    2.  두 오퍼레이션이 **같은 데이터에 접근**해야 한다.
    3.  두 오퍼레이션 중 **최소한 하나는 쓰기(Write) 오퍼레이션**이어야 한다.
    *   **충돌의 종류**:
        *   **읽기-쓰기 충돌(Read-Write Conflict)**: 하나는 읽기, 다른 하나는 쓰기인 경우.
        *   **쓰기-쓰기 충돌(Write-Write Conflict)**: 둘 다 쓰기인 경우.
    *   **중요성**: 충돌하는 오퍼레이션들은 **순서가 바뀌면 결과도 바뀌기 때문에** 중요하다.

*   **충돌 동일성(Conflict Equivalence)의 정의**
    두 스케줄이 다음 두 조건을 **모두 만족**하면 충돌 동일하다고 말한다.
    1.  두 스케줄이 **같은 트랜잭션들을 가져야 한다**.
    2.  어떠한 충돌 오퍼레이션의 순서도 **양쪽 스케줄 모두 동일해야 한다**.
    *   예시: 스케줄 3번과 스케줄 2번은 같은 트랜잭션을 포함하며, 모든 충돌 오퍼레이션(3개가 존재)의 순서가 동일하므로 충돌 동일하다.

*   **뷰 동일성(View Equivalence)**: 충돌 동일성만큼은 아니지만 자주 등장하는 스케줄 동일성 개념이다.

### 5. 충돌 직렬성(Conflict Serializability): 성능과 정확성을 모두 잡다
> 충돌 직렬성(Conflict Serializability)은 비직렬 스케줄의 성능 이점은 취하되, 직렬 스케줄과 동일한 결과를 보장하여 이상 현상을 방지하는 중요한 개념이다. 실제 RDBMS는 이러한 직렬성을 보장하는 프로토콜을 사용하여 안정적인 트랜잭션 관리를 수행한다. 

*   어떤 비직렬 스케줄이 **직렬 스케줄과 충돌 동일하다면**, 그 스케줄을 **충돌 직렬 가능(Conflict Serial-Serializable)**하다고 부른다.
*   **중요성**: 충돌 직렬 가능한 비직렬 스케줄은 비직렬 스케줄임에도 불구하고 **정상적인 결과**를 낼 수 있다. 이는 이상한 결과를 만들지 않는 직렬 스케줄과 동일한 결과를 내기 때문이다.
*   예시:
    *   스케줄 3번은 비직렬 스케줄이었음에도 불구하고 스케줄 2번(직렬 스케줄)과 충돌 동일하므로, **충돌 직렬 가능한 스케줄**이다.
    *   스케줄 4번은 어떤 직렬 스케줄(스케줄 1번, 스케줄 2번)과도 충돌 동일하지 않으므로, **충돌 직렬 가능하지 않은 스케줄**이다. 따라서 스케줄 4번은 로스트 업데이트와 같은 이상한 결과를 초래하였다.

### 6. 실제 RDBMS 구현 방식

실제 관계형 데이터베이스 관리 시스템(RDBMS)에서는 트랜잭션이 실행된 후 해당 스케줄이 충돌 직렬 가능한지 확인하는 방식은 사용하지 않는다. 이는 요청이 많이 몰려 동시에 실행될 수 있는 트랜잭션 수가 너무나도 많기 때문에 그 많은 트랜잭션들의 스케줄이 충돌 직렬 가능한지 확인하는 것이 비용이 많이 들기 때문인 것으로 추정한다.

*   따라서 RDBMS는 여러 트랜잭션을 동시에 실행해도 스케줄이 **충돌 직렬 가능하게 보장하는 프로토콜**을 적용하는 방식으로 구현한다. 즉, 일단 실행하고 나서 충돌 직렬 가능한지 확인하는 것이 아니라, 아예 충돌 직렬 가능한 스케줄만 실행되도록 보장하는 프로토콜을 적용한다.

### 7. 직렬성과 관련된 핵심 개념들

*   **동시성 제어(Concurrency Control)**: 어떤 스케줄이든 직렬 가능하게 만드는 역할을 수행하는 것이 바로 **동시성 제어**이다. 동시성 제어는 모든 스케줄이 직렬 가능하게 동작할 수 있도록 만들어주는 역할을 한다.
*   **격리(Isolation)**: ACID 속성 중 하나인 격리(Isolation)는 이 직렬성과 밀접하게 관련되어 있다.
*   **격리 수준(Isolation Level)**: 격리를 너무 엄격하게(직렬성 완벽 추구) 하면 성능이 저하된다. 이는 제약사항으로 인해 동시성이 떨어지기 때문이다. 따라서 개발자가 필요에 따라 유연하게 선택할 수 있도록 완화된 격리 수준을 제공하는데, 이를 **격리 수준**이라 부른다.
  

## 핵심 용어
- 트랜잭션 (Transaction): 데이터베이스에서 수행되는 하나 이상의 오퍼레이션으로 구성된 논리적인 작업 단위. 원자성, 일관성, 고립성, 지속성(ACID) 속성을 가짐.
- 오퍼레이션 (Operation): 트랜잭션을 구성하는 가장 기본적인 동작. (예: Read, Write, Commit)
- 스케줄 (Schedule): 여러 트랜잭션의 오퍼레이션들이 동시에 실행될 때, 이들이 실행되는 시간적 순서.
- 시리얼 스케줄 (Serial Schedule): 모든 트랜잭션이 다른 트랜잭션의 실행과 겹치지 않고 한 번에 하나씩 순차적으로 실행되는 스케줄.
- 논-시리얼 스케줄 (Non-Serial Schedule): 여러 트랜잭션의 오퍼레이션들이 시간적으로 겹쳐서(interleaving) 실행되는 스케줄. 동시성을 높여 성능을 개선할 수 있음.
- 인터리빙 (Interleaving): 논-시리얼 스케줄에서 여러 트랜잭션의 오퍼레이션들이 번갈아가며 실행되는 방식.
- 로스트 업데이트 (Lost Update): 두 개 이상의 트랜잭션이 동일한 데이터에 대해 쓰기 작업을 수행할 때, 한 트랜잭션의 쓰기 결과가 다른 트랜잭션의 쓰기 결과에 의해 덮어씌워져 사라지는 동시성 문제.
- 컨플릭트 (Conflict): 서로 다른 트랜잭션에 속하고, 동일한 데이터에 접근하며, 최소 하나는 쓰기(Write) 오퍼레이션인 두 오퍼레이션 간의 관계. 컨플릭트의 순서가 바뀌면 스케줄의 결과가 달라짐.
- 읽기-쓰기 컨플릭트 (Read-Write Conflict): 한 트랜잭션이 데이터를 읽은 후 다른 트랜잭션이 동일한 데이터를 쓰는(혹은 그 반대) 경우 발생하는 컨플릭트.
- 쓰기-쓰기 컨플릭트 (Write-Write Conflict): 두 트랜잭션이 동시에 동일한 데이터에 대해 쓰기 작업을 수행할 때 발생하는 컨플릭트.
- 커밋 (Commit): 트랜잭션이 성공적으로 완료되어 모든 변경 사항을 데이터베이스에 영구적으로 반영하는 오퍼레이션.
- 컨플릭트 이퀴벌런트 (Conflict Equivalence): 두 스케줄이 동일한 트랜잭션을 포함하고, 모든 컨플릭트 오퍼레이션 쌍의 순서가 두 스케줄에서 동일할 때 이들을 '컨플릭트 이퀴벌런트'하다고 함.
- 시리얼라이저빌리티 (Serializability): 논-시리얼 스케줄이 어떤 시리얼 스케줄과 동일한 최종 결과를 생성하는 속성. 동시성 제어의 주요 목표.
- 컨플릭트 시리얼라이저빌리티 (Conflict Serializability): 논-시리얼 스케줄이 어떤 시리얼 스케줄과 컨플릭트 이퀴벌런트할 때 해당 스케줄이 '컨플릭트 시리얼라이저블'하다고 함. 이는 정상적인 결과(이상 현상 없음)를 보장함.
- 뷰 이퀴벌런트 (View Equivalence): 스케줄의 동일성을 정의하는 또 다른 기준으로, 트랜잭션들이 읽는 데이터의 초기/최종 값과 최종 쓰기 값의 순서가 동일할 때 두 스케줄이 '뷰 이퀴벌런트'하다고 함. 
- 뷰 시리얼라이저빌리티 (View Serializability): 스케줄이 어떤 시리얼 스케줄과 뷰 이퀴벌런트할 때 해당 스케줄이 '뷰 시리얼라이저블'하다고 함. 
- 동시성 제어 (Concurrency Control): 여러 트랜잭션이 동시에 실행될 때, 데이터베이스의 일관성과 무결성을 유지하면서 시리얼라이저블한 스케줄을 보장하기 위한 메커니즘.
- 아이솔레이션 (Isolation): 트랜잭션의 ACID 속성 중 하나. 동시 실행되는 트랜잭션들이 서로 독립적으로 실행되는 것처럼 보이도록 하는 속성.
- 아이솔레이션 레벨 (Isolation Level): SQL 표준에서 정의된 트랜잭션 고립 수준. 개발자가 필요에 따라 아이솔레이션의 엄격함을 조절할 수 있도록 완화된 고립 수준을 제공함.
- 회복성 (Recoverability): 시스템 장애나 트랜잭션 롤백 시 데이터베이스를 일관된 상태로 되돌릴 수 있는 능력. 