## 데이터베이스 정규화: 3NF, BCNF, 그리고 역정규화(Denormalization)

### 3NF(Third Normal Form): 이행적 함수 종속 제거

데이터베이스 정규화의 다음 단계는 3NF다. 3NF는 데이터 중복을 줄이는 데 중요한 역할을 한다.

#### 이행적 함수 종속(Transitive Functional Dependency)

3NF를 이해하기 위해서는 먼저 이행적 함수 종속의 개념을 알아야 한다.
**이행적 함수 종속**은 X가 Y를 함수적으로 결정하고(X → Y), Y가 Z를 함수적으로 결정할 때(Y → Z), 최종적으로 X가 Z를 함수적으로 결정하는(X → Z) 형태의 종속성을 말한다. 여기서 **중요한 제약 조건**이 있는데, Y와 Z는 **어떤 키(Key)의 부분 집합도 아니어야 한다**.

예를 들어, `Employee ID`가 `Employee Name`을 결정하는 경우(`Employee ID` → `Employee Name`)를 볼 수 있다. 이때, `Employee ID`는 프라이머리 키다. 이러한 이행적 함수 종속이 존재하면 데이터 중복이 발생한다. `Employee ID`가 `Employee Name`을 결정하는데, 만약 `Employee ID`가 키를 통해 다른 속성과 이행적으로 연결되면, 이와 관련된 데이터 (`Employee Name` 등)가 중복되어 생성된다. 예를 들어, 생일, 주소, 전화번호와 같은 정보들도 `Employee ID`에 함수적으로 종속될 수 있다.

#### 3NF의 규칙과 해결 방안

3NF는 이러한 데이터 중복을 제거하기 위해 정의된다. 3NF의 규칙은 다음과 같다:

- **모든 논 프라임 애트리뷰트(Non-Prime Attribute)는 어떤 키(Key)에 대해서도 이행적(transitive)으로 종속되면 안 된다**.
- 좀 더 쉽게 설명하면, **논 프라임 애트리뷰트와 논 프라임 애트리뷰트 사이에는 함수 종속이 존재해서는 안 된다**.

3NF 위반 상황을 해결하는 방법은 **해당 함수 종속을 제거**하는 것이다. 이를 위해 다음과 같은 작업을 수행한다:

1.  **새로운 테이블을 생성**하여 이행적 함수 종속을 형성하는 애트리뷰트들을 옮긴다. 예를 들어, `Employee ID`와 `Employee Name`을 새로운 테이블로 분리한다.
2.  새로운 테이블의 프라이머리 키는 원래 테이블에서 종속성을 결정하던 애트리뷰트(`Employee ID`)가 된다. 이렇게 하면 새로운 테이블에서 중복된 데이터를 입력할 필요가 없어진다.
3.  **원래 테이블에서 종속되던 애트리뷰트(`Employee Name`)를 삭제**한다.
4.  그러나 **원래 테이블에서 종속성을 결정하던 애트리뷰트(`Employee ID`)는 삭제해서는 안 된다**. 이는 나중에 두 테이블을 조인할 때 연결 고리 역할을 하기 때문이다.

이 과정을 통해 중복된 데이터가 자연스럽게 사라지고, 테이블은 3NF를 만족하게 된다.

### BCNF(Boyce-Codd Normal Form): 모든 함수 종속의 결정자가 슈퍼키

BCNF는 3NF보다 더욱 엄격한 정규화 형태다. BCNF는 특정 중복 데이터, 특히 테이블 내에서 특정 애트리뷰트 값이 제한적이고 다른 애트리뷰트를 결정할 때 발생하는 중복을 해결하는 데 중점을 둔다.

#### BCNF의 규칙

BCNF의 규칙은 다음과 같다:

- **모든 유효한 논 트리비얼(Non-Trivial) 함수 종속 X → Y에 대해, 레프트 핸드 사이드(Left-Hand Side)에 있는 X는 반드시 슈퍼키(Superkey)여야 한다**.
  - **논 트리비얼 함수 종속**: Y가 X의 부분 집합이 아닌 경우를 의미한다.
  - **슈퍼키**: 해당 테이블에서 튜플(Tuple)을 유니크하게 식별할 수 있는 애트리뷰트의 집합을 말한다.

#### BCNF 위반 사례와 해결 방안

예를 들어, `Class` 애트리뷰트가 `Bank Name`을 함수적으로 결정하는 경우(`Class` → `Bank Name`)를 생각해 볼 수 있다. 즉, `Class`가 같으면 `Bank Name`도 같다고 할 수 있다. 이 경우 `Class`는 해당 테이블의 슈퍼키가 아니다. 왜냐하면 `Class`만으로는 테이블의 튜플을 유니크하게 식별할 수 없기 때문이다. 따라서 이 함수 종속은 BCNF를 위반한다. 이로 인해 `Bank Name`과 같은 애트리뷰트에 중복된 데이터가 계속 쌓일 수 있다.

BCNF를 만족시키기 위한 해결책도 **테이블을 쪼개는 것**이다:

1.  **위반하는 함수 종속(X → Y)을 기반으로 새로운 테이블을 생성**한다. 예를 들어, `Class`와 `Bank Name`을 애트리뷰트로 가지는 새 테이블을 만든다.
2.  새로운 테이블에는 해당 함수 종속에 해당하는 고유한 데이터만 채운다.
3.  **원래 테이블에서 종속되던 애트리뷰트(Y, 즉 `Bank Name`)를 삭제**한다.
4.  마찬가지로 **결정자 애트리뷰트(X, 즉 `Class`)는 원래 테이블에 남아 있어야 한다**. 이는 조인을 위한 연결 고리 역할을 한다.

이 과정을 통해 원래 테이블에 데이터가 계속 쌓여도 `Bank Name`과 같은 애트리뷰트의 중복 데이터는 더 이상 발생하지 않는다.

### 역정규화(Denormalization): 성능과 관리 효율성을 위한 전략적 선택

정규화는 데이터의 일관성과 무결성을 높이지만, 테이블을 너무 잘게 쪼개면 문제가 발생할 수도 있다.

- **성능 저하**: 여러 테이블을 동시에 조인(Join)해야 하는 경우가 많아지면서 쿼리 성능이 느려질 수 있다.
- **관리의 어려움**: 너무 많은 테이블은 관리하기 복잡해질 수 있다.

이러한 문제 때문에, **디노멀라이제이션(Denormalization)**, 즉 **역정규화 또는 반정규화**라는 개념이 등장한다. 역정규화는 정규화의 반대 과정으로, **전략적으로 테이블을 덜 쪼개거나, 이미 쪼개진 테이블을 다시 합치는 과정**을 의미한다.

역정규화는 데이터베이스 설계 시 **과도한 조인과 중복 데이터의 최소화 사이에서 적정 수준을 선택**하는 실무적인 판단이다. 예를 들어, BCNF까지 정규화하는 대신 3NF까지만 정규화하는 것을 선택할 수도 있다. 이는 성능과 관리 효율성을 위해 의도적으로 중복을 허용하는 것이다.

데이터베이스 설계자는 정규화와 역정규화 사이에서 균형을 찾아야 하며, 이는 실제 업무 환경에서 매우 중요한 부분이다.

1NF부터 BCNF 외에도 더 높은 수준의 정규형(예: 4NF, 5NF)이 존재하지만, 사용 빈도 대비 설명해야 할 내용이 많아 일반적으로는 BCNF까지의 개념이 주로 다루어진다.
