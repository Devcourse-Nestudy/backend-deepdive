### 1\. RDB (관계형 데이터베이스)의 단점

RDB는 데이터의 일관성과 무결성을 보장하는 강력한 도구이지만, 현대적인 웹 환경의 요구사항을 모두 만족시키기에는 몇 가지 한계점을 가집니다.

- **Schema 변경의 어려움**

  - 새로운 기능을 위해 `Column`을 추가하는 등 `Schema`를 변경해야 할 때, 이미 방대한 양의 데이터가 저장되어 있다면 `Schema` 변경은 매우 어렵고 서비스 중단으로 이어질 수 있는 위험한 작업이 됩니다.

- **Join으로 인한 성능 문제**

  - 데이터 중복을 최소화하기 위해 \*\*`Normalization` (정규화)\*\*을 수행합니다. 이로 인해 원본 데이터를 조회하려면 여러 테이블을 **`Join`** 해야 하는데, `Join` 연산이 많아질수록 성능 저하의 원인이 될 수 있습니다.

- **Scale-out의 한계**

  - 성능 향상을 위해 주로 **`Scale-up`** (더 좋은 하드웨어로 교체)이나 **`Replication`** (읽기 전용 서버 추가) 방식을 사용합니다. 데이터를 분산 저장하는 \*\*`Sharding`\*\*을 통해 **`Scale-out`** (서버 대수 증가)도 가능하지만, 설계와 구현이 복잡하고 어렵습니다.

- **ACID 준수의 Trade-off**

  - `Transaction`과 **`ACID`** 원칙을 통해 데이터의 **무결성**을 강력하게 보장하지만, 이러한 엄격함이 오히려 성능에는 부담이 됩니다. 이로 인해 **`High-throughput`** (높은 처리량)과 **`Low-latency`** (낮은 지연 시간)를 요구하는 환경에서는 성능적 한계에 부딪힐 수 있습니다.

- **비정형 데이터 처리의 한계**

  - 텍스트, 이미지, JSON 등 정형화되지 않은 데이터가 증가하면서, 고정된 `Schema`를 가진 RDB와 `SQL`만으로는 이러한 데이터를 유연하게 저장하고 처리하는 데 어려움이 따릅니다.

---

### 2\. NoSQL의 등장

`NoSQL`은 위에서 언급한 RDB의 한계를 극복하기 위한 대안으로 등장했으며, 다음과 같은 특징을 가집니다.

- **Flexible Schema**

  - `NoSQL`의 가장 큰 특징은 미리 `Schema`를 엄격하게 정의할 필요가 없다는 점입니다. 덕분에 다양한 형태의 데이터를 자유롭게 저장하고 변경할 수 있습니다.
  - **SQL과 MongoDB 용어 비교**
    | SQL (`RDB`) | MongoDB (`NoSQL`) |
    | :---------- | :------------------ |
    | Table | `Collection` |
    | Row | `Document` |
    | Column | `Field` |
  - **기본 명령어 예시**
    | SQL | MongoDB |
    | :-- | :-- |
    | `INSERT` | `insertOne` |
    | `SELECT` | `find` |

    ```javascript
    // 데이터 삽입 예시
    db.student.insertOne({ name: 'easycode', major: 'Computer Science' });

    // 데이터 조회 예시
    db.student.find({ name: 'easycode' });
    ```

- **Join 회피를 위한 데이터 중복 허용**

  - 관련 데이터를 하나의 `Document`에 함께 저장하는 **`Embedding`** 방식을 통해 `Join` 연산을 최소화합니다. 이를 통해 데이터 조회 성능을 높일 수 있습니다.
  - 단, 데이터가 중복 저장되므로 **데이터 불일치**가 발생할 수 있으며, 이는 애플리케이션 레벨에서 일관성을 유지하도록 관리해야 합니다.

- **Scale-out에 최적화된 구조**

  - 여러 서버에 데이터를 분산 저장하는 \*\*`Sharding`\*\*을 기본적으로 지원하여 **`Scale-out`** (수평 확장)에 매우 유리합니다. 저렴한 서버 여러 대로 손쉽게 전체 시스템의 용량과 성능을 확장할 수 있습니다.

- **성능을 위한 ACID 완화**

  - 엄격한 `ACID` 대신 **`BASE`** (`Basically Available`, `Soft state`, `Eventually consistent`) 모델을 따르는 경우가 많습니다. 데이터 일관성을 일부 희생하는 대신, \*\*`High-throughput`\*\*과 \*\*`Low-latency`\*\*를 확보하여 빠른 응답 속도를 보장합니다.
  - 이러한 특성 때문에 데이터 `Consistency`(일관성)가 절대적으로 중요한 금융 시스템 등에는 신중하게 적용해야 합니다.

---

### 3\. Redis (인메모리 데이터 스토어)

`Redis`는 `NoSQL`의 일종으로, 특히 `Cache`나 세션 스토어 등으로 널리 활용됩니다.

#### 3.1 특징

- **In-memory 기반**: 모든 데이터를 **메모리**에 저장하여 디스크 기반의 DB보다 월등히 빠른 속도를 자랑합니다.
- **Key-Value 구조**: 모든 데이터를 `Key-Value` 형태로 저장합니다.
- **다양한 자료구조 지원**: 단순 `Strings` 뿐만 아니라 `Lists`, `Sets`, `Hashes`, `Sorted Sets` 등 활용도 높은 자료구조를 지원하여 다양한 시나리오에 적용할 수 있습니다.
- **고가용성 및 확장성**: `Replication`(복제) 및 `Automatic Failover`(자동 장애 복구) 기능으로 **`High Availability`** (고가용성)를 지원하며, `Hash-based Sharded Cluster`를 통해 수평 확장이 용이합니다.

#### 3.2 캐시(Cache)로서의 동작 방식

`Redis`를 데이터베이스 앞단의 캐시로 사용할 경우, 시스템의 성능을 크게 향상시킬 수 있습니다.

1.  **데이터 요청**: 클라이언트(`Front-end`)가 서버(`Back-end`)에 데이터를 요청합니다.
2.  **캐시 확인**: 서버는 DB에 접근하기 전, 가장 먼저 `Redis` 캐시에 데이터가 있는지 확인합니다.
3.  **Cache Hit (캐시에 데이터가 있는 경우)**
    - DB에 접근할 필요 없이, `Redis`에서 즉시 데이터를 가져와 클라이언트에게 응답합니다.
    - 이를 통해 DB의 부하를 줄이고 매우 빠른 응답 속도를 제공할 수 있습니다.
4.  **Cache Miss (캐시에 데이터가 없는 경우)**
    - `데이터베이스(DB)`에 직접 접근하여 데이터를 조회합니다.
    - 조회한 데이터를 `Key-Value` 형태로 가공하여 `Redis`에 **저장**합니다. 이때, 데이터가 캐시에 머무를 시간(**`TTL`: Time To Live**)을 설정하여 일정 시간이 지나면 자동으로 삭제되게 할 수 있습니다.
    - DB에서 가져온 데이터를 클라이언트에게 응답합니다.
