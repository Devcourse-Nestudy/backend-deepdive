### 1. DB 파티셔닝 (Partitioning)

**파티셔닝은 데이터베이스의 테이블을 더 작은 크기의 테이블들로 나누는 것을 의미합니다**. 이는 크게 두 가지 방식으로 나뉨이 된다.

- **버티컬 파티셔닝 (Vertical Partitioning)**

  - **컬럼을 기준으로 테이블을 나누는 방식이 된다**.
  - 파티셔닝 후에는 테이블의 스키마가 달라지게 된다.
  - **목적 및 예시**:

    - **정규화**: 데이터 중복을 방지하고 데이터 이상 현상을 막기 위해 테이블을 여러 개의 테이블로 분리하는 과정 자체가 버티컬 파티셔닝에 해당된다.
    - **성능 개선**: 자주 사용되지 않거나 크기가 큰 컬럼(예: 게시글 내용)을 분리하여 불필요한 I/O 부담을 줄이고 조회 속도를 향상시킬 수 있다. `Article` 테이블에서 `Content` 컬럼을 분리하여 `Article_Content` 테이블로 만들 수 있다.

      ```
      기존 Article 테이블:
      | ID | Title | Author_ID | Created_At | View_Count | Comment_Count | Content |
      |----|-------|-----------|------------|------------|---------------|---------|

      버티컬 파티셔닝 후:
      Article 테이블:
      | ID | Title | Author_ID | Created_At | View_Count | Comment_Count |
      |----|-------|-----------|------------|------------|---------------|

      Article_Content 테이블:
      | Article_ID | Content |
      |------------|---------|
      ```

    - **보안 강화**: 민감한 정보를 특정 컬럼에 모아 별도의 테이블로 분리하여 접근 제한을 걸 수 있다.
    - **사용 빈도에 따른 분리**: 자주 사용되는 컬럼끼리, 자주 사용되지 않는 컬럼끼리 모아 파티션을 구성할 수 있다.

  - 원래의 전체 데이터가 필요한 경우에는 `JOIN`을 사용하여 데이터를 가져올 수 있다.

- **호리젠탈 파티셔닝 (Horizontal Partitioning)**

  - **로우(행)를 기준으로 테이블을 나누는 방식이 된다**.
  - 버티컬 파티셔닝과는 달리, 파티셔닝 후에도 **테이블의 스키마는 그대로 유지된다**.
  - **해결하는 문제**: 테이블의 데이터가 많아질수록 인덱스 크기가 커져 읽기 및 쓰기 처리 시간이 늘어나는 문제를 해결한다. 예를 들어, 구독 정보(`Subscription`) 테이블은 사용자 수와 채널 수에 따라 최대 10억 개의 로우를 가질 수 있으며, 이는 매우 거대한 크기가 될 수 있다.
  - **해시 기반 파티셔닝 (가장 많이 사용되는 방법 중 하나)**:

    - **해시 함수(Hash Function)를 사용하여 로우를 분리한다**. 예를 들어, `User_ID`를 해시 함수에 넣으면 0 또는 1이라는 값이 나온다고 가정하면, 해당 값에 따라 `Subscription_Zero` 또는 `Subscription_One` 테이블에 저장된다.

      ```
      Subscription 테이블:
      | User_ID | Channel_ID | Alarm_Setting | Membership_Level |
      |---------|------------|---------------|------------------|
      | aaa     | 1          | true          | gold             |
      | bbb     | 2          | false         | silver           |
      | soo     | 1          | true          | platinum         |

      해시 함수 적용 (User_ID에 따라 0 또는 1 반환):
      - aaa -> 0
      - bbb -> 0
      - soo -> 1

      호리젠탈 파티셔닝 후:
      Subscription_Zero 테이블:
      | User_ID | Channel_ID | Alarm_Setting | Membership_Level |
      |---------|------------|---------------|------------------|
      | aaa     | 1          | true          | gold             |
      | bbb     | 2          | false         | silver           |

      Subscription_One 테이블:
      | User_ID | Channel_ID | Alarm_Setting | Membership_Level |
      |---------|------------|---------------|------------------|
      | soo     | 1          | true          | platinum         |
      ```

    - **파티션 키 (Partition Key)**: 데이터를 나눌 기준으로 사용되는 컬럼을 의미하며, 위 예시에서는 `User_ID`가 된다.
    - **파티션 키의 중요성**:
      - 파티션 키를 이용한 조회는 특정 테이블에서만 데이터를 찾으면 되므로 매우 효율적이다.
      - **파티션 키가 아닌 컬럼으로 조회할 경우**, 모든 분리된 테이블을 조회해야 할 수 있어 비효율적이 된다. 따라서 **가장 많이 사용될 조회 패턴에 따라 파티션 키를 정하는 것이 중요한다**.
    - **데이터 균등 분배**: 해시 함수를 잘 정의하여 데이터가 여러 테이블에 균등하게 분배되도록 하는 것이 중요한다.
    - **주의 사항**: 해시 기반 파티셔닝은 **한번 파티션이 나눠지면 이후에 새로운 파티션을 추가하기가 대단히 까다롭다**. 서비스 운영 중에 데이터를 옮기는 과정이 복잡하므로, **처음 설계할 때 신중하게 계획해야 한다**.

### 2. 샤딩 (Sharding)

**샤딩은 호리젠탈 파티셔닝으로 나누어진 각 테이블들을 독립된 DB 서버에 저장하는 방식이 된다**.

- **호리젠탈 파티셔닝과의 차이점**:
  - 호리젠탈 파티셔닝은 나누어진 모든 테이블이 같은 DB 서버에 저장될 수 있지만, **샤딩은 각 파티션(테이블)이 서로 다른 물리적인 DB 서버에 저장된다는 점이 핵심 차이점이다**.
- **목적 및 효과**:
  - 하나의 DB 서버에 모든 부하가 집중되는 것을 방지하고, **DB 서버의 부하를 분산시키는 효과를 가져온다**.
  - `Subscription_Zero` 테이블은 DB 서버 A에, `Subscription_One` 테이블은 DB 서버 B에 저장될 수 있다.
  ```
  백엔드 서버
      |
      |--- 요청 (User_ID 'aaa') --> DB 서버 A (Subscription_Zero 테이블)
      |
      |--- 요청 (User_ID 'soo') --> DB 서버 B (Subscription_One 테이블)
  ```
- **용어**:
  - **샤드 키 (Shard Key)**: 파티션 키와 동일한 개념으로, 샤딩 환경에서 데이터를 분산시키는 기준이 되는 컬럼을 의미한다.
  - **샤드 (Shard)**: 독립된 DB 서버에 저장된 각 파티션을 의미한다.

### 3. 레플리케이션 (Replication)

**레플리케이션은 DB를 복제하여 여러 대의 DB 서버에 저장하는 방식이 된다**.

- **동작 방식**:
  - 하나의 **주 DB 서버(마스터/프라이머리/리더)**가 존재하며, 이 서버의 데이터를 **보조 DB 서버(슬레이브/세컨더리/레플리카)**들이 계속해서 복사(카피)하여 똑같은 데이터를 유지하게 된다. '슬레이브'라는 용어는 구시대적 표현으로 여겨짐이 된다.
  - 주 DB 서버에서 데이터 추가, 수정, 삭제가 발생하면, 보조 DB 서버에도 동일하게 적용되어 항상 데이터의 동기화가 유지된다.
  - 보조 DB 서버는 한 대 이상 존재할 수 있다.
- **목적 및 장점**:

  - **고가용성 (High Availability, HA) 보장**: 주 DB 서버에 문제가 발생했을 때, 백엔드 서버가 빠르게 보조 DB 서버로 전환(페일오버)하여 **서비스가 중단 없이 지속될 수 있도록 한다**.
  - **읽기(Read) 부하 분산**: 대부분의 서비스는 쓰기(Write)보다 읽기 요청이 훨씬 많기 때문에, **읽기 쿼리의 일부를 보조 DB 서버로 분산시켜 주 DB 서버의 부하를 줄일 수 있다**.

  ```
  평상 시:
  백엔드 서버
      |--- Write/Read 요청 --> 주 DB 서버 (마스터/프라이머리)
                                  |
                                  |--- 데이터 복제 (카피)
                                  V
                                보조 DB 서버 (슬레이브/세컨더리)

  읽기 부하 분산 시:
  백엔드 서버
      |--- Write 요청  --------> 주 DB 서버
      |                               ^
      |--- Read 요청 (일부) --------|
      |
      |--- Read 요청 (나머지) --> 보조 DB 서버

  장애 발생 시:
  백엔드 서버
      |
      |--- (주 DB 서버 장애 발생)
      |
      |--- 모든 요청 (페일오버) --> 보조 DB 서버
  ```
