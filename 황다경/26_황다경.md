## 파티셔닝, 샤딩, 레플리케이션

데이터베이스를 효율적으로 관리하고 성능을 최적화하기 위해 파티셔닝, 샤딩, 레플리케이션과 같은 다양한 기법을 사용한다. 이 기술들은 각각 다른 목적과 특징을 가지고 있다.

### 1. 파티셔닝 (Partitioning)

**파티셔닝은 데이터베이스의 테이블을 더 작은 크기의 테이블들로 나누는 것을 의미한다**. 파티셔닝은 크게 두 가지 종류로 나눌 수 있다.

- **수직 파티셔닝 (Vertical Partitioning)**

  - **컬럼을 기준으로 테이블을 나누는 방식이다**.
  - **정규화(Normalization)**는 수직 파티셔닝의 한 예시가 될 수 있다. 정규화는 데이터 중복을 방지하고 데이터 조작(INSERT, UPDATE, DELETE) 시 발생하는 이상 현상을 막기 위해 수행된다. 이 과정에서 하나의 큰 테이블이 컬럼을 기준으로 여러 개의 작은 테이블로 나뉘게 된다.
  - 정규화 외에도 성능 개선을 목적으로 수직 파티셔닝을 수행할 수 있다.
    - 예를 들어, 게시글 정보를 저장하는 `Article` 테이블에 ID, 제목, 작성자 ID, 작성일, 조회수, 댓글 수 등의 정보와 함께 **게시글 내용(Content)**과 같이 **사이즈가 큰 데이터**가 포함되어 있는 경우를 가정한다.
    - 사용자에게 게시글 목록을 보여줄 때에는 내용(Content)을 제외한 나머지 정보(ID부터 댓글 수까지)만 필요하다.
    - 그러나 쿼리가 실행될 때, 하드디스크나 SSD에서 해당 로우의 전체 데이터를 읽어와 메모리에 올린 후 필요한 컬럼만 필터링하게 된다. 이때 `Content`와 같이 크기가 큰 데이터까지 불필요하게 읽어오면서 **I/O(입출력) 부담**이 발생하고 시간이 낭비될 수 있다. 특히 풀 스캔(Full Scan) 시에는 성능에 악영향을 줄 수 있다.
    - 이러한 문제를 해결하기 위해 **수직 파티셔닝을 사용하여 `Content` 컬럼을 `ArticleContent`와 같은 별도의 테이블로 분리할 수 있다**.
    - 이렇게 되면 게시글 목록을 조회할 때 `Article` 테이블에만 빠르게 셀렉트 쿼리를 수행할 수 있어 성능이 향상된다.
    - 전체 데이터가 필요할 경우에는 `JOIN` 연산을 통해 분리된 테이블들을 다시 결합하여 사용할 수 있다.
  - 다른 목적으로는 민감한 정보에 대한 접근 제한을 강화하거나, 자주 사용되는 애트리뷰트와 자주 사용되지 않는 애트리뷰트를 분리하여 파티션을 구성하는 경우도 있다.
  - 수직 파티셔닝은 컬럼을 기준으로 나누므로 파티셔닝 후에는 테이블의 스키마가 달라진다.

- **수평 파티셔닝 (Horizontal Partitioning)**
  - **로우(row)를 기준으로 테이블을 나누는 방식이다**.
  - 이 방식은 테이블의 스키마를 그대로 유지한다. 로우를 기준으로 나누기 때문에 기존 테이블의 스키마는 변하지 않는 특성이 있다.
  - 대규모 서비스에서 테이블의 데이터가 많아질수록 발생하는 문제점을 해결하기 위해 사용된다.
    - 예를 들어, 유튜브 구독 정보와 유사한 `Subscription` 테이블이 있다고 가정한다. 사용자 수(N)와 채널 수(M)가 많아지면 (예: 100만 명 사용자 \* 1000개 채널 = 최대 10억 개의 구독 정보) 테이블의 크기가 매우 커진다.
    - 테이블의 크기가 커지면 **테이블에 걸린 인덱스의 크기 또한 커진다**. 이는 인덱스 검색 시간이나 쓰기 작업(INSERT, UPDATE, DELETE 시 B-트리 조정)에 소요되는 시간을 증가시켜 전체적인 성능 저하로 이어질 수 있다.
  - **해시(Hash) 기반 수평 파티셔닝**은 이러한 문제 해결에 많이 사용되는 방법 중 하나이다.
    - 해시 함수를 사용하여 특정 기준(예: 사용자 ID)을 입력받아 출력값(예: 0 또는 1)에 따라 데이터를 여러 개의 동일한 스키마를 가진 테이블(예: `Subscription_Zero`, `Subscription_One`)에 분산하여 저장한다.
    - 이때 데이터를 분산시키는 기준이 되는 사용자 ID를 **파티션 키(Partition Key)**라고 부른다.
    - **장점**: 파티션 키(예: 유저 ID)를 기반으로 데이터를 조회할 경우, 관련된 데이터가 특정 파티션에만 존재하므로 해당 파티션 테이블만 조회하여 빠르게 결과를 얻을 수 있다.
    - **주의사항**:
      - **파티션 키의 중요성**: 파티션 키가 아닌 다른 컬럼(예: 채널 ID)으로 조회할 경우에는 모든 파티션 테이블을 조회해야 하므로 성능 이점을 누리기 어렵다. 따라서 가장 많이 사용될 조회 패턴에 따라 파티션 키를 정하는 것이 중요하다.
      - **해시 함수의 설계**: 데이터가 균등하게 여러 테이블에 분배될 수 있도록 해시 함수를 잘 정의하는 것이 중요하다.
      - **파티션 재분배의 어려움**: 한 번 파티션이 나뉘어 서비스에 적용되면, 이후에 파티션을 추가(예: 2개에서 4개로 확장)하는 과정이 매우 까다롭다. 이미 저장된 데이터 중 일부를 새로운 파티션으로 옮겨야 하므로 서비스 운영 중에는 이러한 작업이 매우 어렵다. 따라서 초기 파티셔닝 설계 시 신중하게 계획해야 한다.
  - 해시 외에도 범위(Range) 기반 등 여러 수평 파티셔닝 방법이 존재한다.

### 2. 샤딩 (Sharding)

**샤딩은 수평 파티셔닝과 매우 유사하며 동일한 방식으로 동작한다**. 즉, 로우를 기준으로 테이블을 나눈다.

- **샤딩과 수평 파티셔닝의 핵심적인 차이점은 나누어진 각 파티션(테이블)들이 독립된 DB 서버에 저장된다는 점이다**.
- 일반적인 수평 파티셔닝의 경우, 모든 파티션들이 동일한 DB 서버에 저장될 수 있어 하드웨어 자원(CPU, 메모리)이 한정적이라는 문제가 있다.
- 반면 샤딩은 각 테이블을 서로 다른 DB 서버에 저장함으로써, 백엔드 서버로부터의 요청 트래픽이 각 DB 서버로 분산되어 **DB 서버의 부하를 분산시키는 효과**를 얻을 수 있다.
- 규모가 큰 서비스에서 데이터가 많이 쌓이거나 트래픽이 집중되는 테이블에 샤딩을 적용하여 각 파티션마다 독립된 DB 서버를 할당하고 트래픽을 분산시켜 DB 서버의 부하를 낮춘다.
- 샤딩에서는 파티션 키를 **샤드 키(Shard Key)**라고 부르며, 각 파티션을 **샤드(Shard)**라고 부른다.

### 3. 레플리케이션 (Replication)

**레플리케이션은 데이터베이스를 복제하여 여러 대의 DB 서버에 저장하는 방식이다**.

- **목적**: DB 서버에 문제가 발생했을 때 서비스가 중단되지 않고 계속 유지될 수 있도록 한다.
- **동작 방식**: 하나의 주 DB 서버(마스터/프라이머리/리더)가 있고, 이 주 DB 서버로부터 데이터를 복사하여 동일한 데이터베이스를 유지하는 보조 DB 서버(슬레이브/세컨더리/레플리카)를 둔다.
  - 주 DB 서버에서 데이터가 추가, 수정, 삭제되면 보조 DB 서버에도 동일하게 복사되어 항상 데이터가 동기화된다.
  - 보조 DB 서버는 한 대뿐 아니라 여러 대를 둘 수 있다.
- **장점**:
  - **고가용성 (High Availability, HA) 보장**: 주 DB 서버에 장애가 발생하면 백엔드 서버가 빠르게 보조 DB 서버로 전환(페일오버, Failover)하여 서비스의 타격을 최소화하고 연속성을 유지할 수 있다.
  - **트래픽 분산 (특히 읽기 쿼리)**: 대부분의 서비스는 쓰기(WRITE)보다 읽기(READ) 트래픽이 훨씬 많다. 레플리케이션을 구성하면 주 DB 서버로 몰리는 읽기 쿼리 중 일부를 보조 DB 서버로 분산시켜 처리할 수 있다. 이를 통해 주 DB 서버의 부하를 줄이고 전체적인 성능을 향상시킬 수 있다.

이 세 가지 개념은 각각 테이블을 나누는 방식(파티셔닝), 나누어진 테이블을 별도 서버에 두어 부하를 분산하는 방식(샤딩), 그리고 데이터베이스 자체를 복제하여 가용성과 읽기 부하를 관리하는 방식(레플리케이션)으로 그 목적과 특징이 다르다.
