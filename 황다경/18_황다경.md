## 데이터베이스 동시성 제어: 락(Lock)과 2PL(Two-Phase Locking) 프로토콜

### 1. 동시성 제어의 필요성 및 락(Lock)의 등장

데이터베이스에 10이라는 값을 가진 'x' 데이터가 있다고 가정하자. 트랜잭션 1이 'x'를 20으로 변경하고, 동시에 트랜잭션 2가 'x'를 90으로 변경하려 한다면 예상치 못한 결과가 발생할 수 있다. 단순히 값 하나를 변경하는 것처럼 보여도, 실제로는 인덱스 처리나 파일 저장 처리 등 더 복잡한 과정이 수반되기 때문이다.

이러한 문제를 해결하기 위해 **락(Lock)**이 사용된다. 락은 운영체제에서 배우는 락과 유사한 개념으로, 각 데이터마다 락이 존재하며 해당 데이터를 변경하거나 읽으려면 그 락을 반드시 획득해야 한다. 락을 획득하지 못하면 해당 락이 해제될 때까지 기다려야 한다.

### 2. 락의 종류: 라이트락(Write Lock)과 리드락(Read Lock)

데이터베이스 락은 크게 두 가지 종류로 나뉜다.

*   **라이트락 (Write Lock) 또는 익스클루시브 락 (Exclusive Lock)**
    *   **쓰기(Write) 용도로 주로 사용되지만, 읽기(Read) 용도로도 사용될 수 있다**.
    *   핵심은 **'배타적(Exclusive)'**이라는 점이다. 라이트락을 획득하면 다른 트랜잭션이 같은 데이터에 대해 동시에 읽기나 쓰기를 하는 것을 허용하지 않는다. 즉, 라이트락을 쥐고 있는 동안에는 해당 데이터에 대한 모든 동시 접근이 차단된다.
*   **리드락 (Read Lock) 또는 쉐어드락 (Shared Lock)**
    *   **읽기(Read) 용도로만 사용된다**. 쓰기에는 사용할 수 없다.
    *   특징은 **'공유(Shared)'**라는 점이다. 다른 트랜잭션이 같은 데이터에 대해 동시에 읽기를 시도하는 것은 허용된다. 읽기 작업은 데이터를 변경하지 않기 때문에 여러 트랜잭션이 동시에 읽어도 문제가 발생하지 않는다.
    *   하지만, **내가 리드락을 쥐고 읽고 있는 동안 다른 트랜잭션이 같은 데이터에 대해 쓰기를 시도한다면, 나의 읽기 작업을 보호하기 위해 해당 쓰기 시도는 차단된다**. 즉, 라이트락은 리드락과 호환되지 않는다.

이러한 락들은 **호환성(Compatibility)** 규칙을 가지고 있다.
*   **리드락 - 리드락**: 허용된다. (공유 가능)
*   **리드락 - 라이트락**: 허용되지 않는다. 리드락을 쥐고 있는 동안 라이트락을 얻으려는 트랜잭션은 기다려야 한다.
*   **라이트락 - 리드락**: 허용되지 않는다. 라이트락을 쥐고 있는 동안 리드락을 얻으려는 트랜잭션은 기다려야 한다.
*   **라이트락 - 라이트락**: 허용되지 않는다. 라이트락을 쥐고 있는 동안 다른 라이트락을 얻으려는 트랜잭션은 기다려야 한다.

### 3. 락만으로는 부족하다: 2PL(Two-Phase Locking)의 필요성

단순히 락을 사용하는 것만으로는 트랜잭션의 **직렬성(Serializability)**을 완벽하게 보장할 수 없다. 즉, 트랜잭션들이 순차적으로 실행되는 것과 동일한 결과를 보장할 수 없다는 의미다.

예를 들어, 초기 x=100, y=200인 상황에서 트랜잭션 1은 x+y를 x에 저장하고, 트랜잭션 2는 x+y를 y에 저장하는 시나리오를 생각해보자. 만약 이 두 트랜잭션이 동시에 실행될 경우, 락을 사용했음에도 불구하고 예상치 못한 비정상적인 결과가 발생할 수 있다. 예를 들어, 트랜잭션 2가 x를 읽고 x에 대한 락을 해제한 뒤 y에 대한 라이트락을 획득하려 하는데, 그 사이에 트랜잭션 1이 y에 대한 리드락을 먼저 획득해버려 트랜잭션 2가 블락되는 상황이 발생할 수 있다. 이때 트랜잭션 1이 업데이트되지 않은 y 값을 읽게 되면 최종 결과가 직렬 가능한(Serializable) 스케줄의 결과와 달라지게 된다.

이러한 문제를 해결하기 위해, 락을 획득하고 해제하는 **오퍼레이션의 순서**를 특정 규칙에 따라 바꿔주는 것이 필요하다. 바로 여기서 **2PL(Two-Phase Locking) 프로토콜**이 등장한다.

### 4. 2PL(Two-Phase Locking) 프로토콜의 동작 방식

**2PL 프로토콜**은 트랜잭션 내의 모든 락킹 오퍼레이션(락 획득)이 **최초의 언락(락 해제) 오퍼레이션보다 먼저 수행되도록 하는 규칙**이다. 다르게 설명하면, 한 번 락이 해제되기 시작하면 그 이후로는 새로운 락을 취득하지 않는다는 의미다.

이 프로토콜이 '2-Phase'라고 불리는 이유는 크게 두 단계로 나뉘어 락킹이 동작하기 때문이다.

*   **익스펜딩 페이즈 (Expanding Phase) 또는 그로잉 페이즈 (Growing Phase)**
    *   **락을 획득만 하고 반환하지 않는 단계**다. 필요한 모든 락을 이 단계에서 취득한다.
*   **쉬링킹 페이즈 (Shrinking Phase) 또는 컨트랙팅 페이즈 (Contracting Phase)**
    *   **락을 반환만 하고 더 이상 새로운 락을 취득하지 않는 단계**다.

2PL 프로토콜을 따르면 **트랜잭션의 직렬성이 보장된다**. 앞서 언급했던 비정상적인 결과가 발생했던 예제에서도 2PL 규칙을 적용하여 락 획득과 해제 순서를 조절하자 문제가 해결되고 직렬 가능한 결과가 도출되는 것을 확인할 수 있었다.

### 5. 2PL의 단점: 데드락(Deadlock) 발생 가능성

2PL 프로토콜은 직렬성을 보장하지만, **상황에 따라 데드락(Deadlock)이 발생할 수 있다**는 단점이 있다.

예를 들어, 트랜잭션 1은 'x'에 대한 라이트락을 얻기 위해 트랜잭션 2가 쥐고 있는 'x'의 리드락이 해제되기를 기다리고, 동시에 트랜잭션 2는 'y'에 대한 라이트락을 얻기 위해 트랜잭션 1이 쥐고 있는 'y'의 리드락이 해제되기를 기다리는 상황이 발생할 수 있다. 이처럼 서로가 서로의 락이 해제되기를 무한정 기다리는 상태가 바로 데드락이다. 데드락 해결 방식은 운영체제에서 배우는 방식과 유사하게 적용된다.

### 6. 다양한 2PL 프로토콜 종류

2PL 프로토콜은 여러 종류가 있으며, 각각의 특징은 다음과 같다.

*   **컨저버티브 2PL (Conservative 2PL)**
    *   트랜잭션 시작 전에 **모든 필요한 락을 취득한 뒤에야 트랜잭션을 시작**한다.
    *   **장점**: 데드락이 발생하지 않는다.
    *   **단점**: 모든 락을 동시에 취득하기 어려운 상황이 발생할 수 있어, 트랜잭션 자체가 시작하기 어려워지는 비실용적인 방법이다.
*   **스트리트 2PL (Strict 2PL, S2PL)**
    *   **스트리트 스케줄(Strict Schedule)**을 보장하는 2PL이다. 스트리트 스케줄은 롤백 상황에서도 이상한 현상이 생기지 않도록 하는, 가장 엄격한 스케줄 중 하나다.
    *   **라이트락(Write Lock)은 해당 트랜잭션이 커밋되거나 롤백될 때만 반환**된다.
    *   **장점**: **복구 가능성(Recoverability)을 보장한다**. 즉, 롤백이 발생하더라도 데이터의 일관성을 유지할 수 있다.
*   **스트롱 스트리트 2PL (Strong Strict 2PL, SS2PL) 또는 리고로스 2PL (Rigorous 2PL)**
    *   S2PL과 마찬가지로 스트리트 스케줄과 복구 가능성을 보장한다.
    *   S2PL과의 차이점은 **라이트락뿐만 아니라 리드락(Read Lock) 또한 해당 트랜잭션이 커밋되거나 롤백될 때 반환**된다는 점이다.
    *   **장점**: S2PL보다 구현이 좀 더 쉽다.
    *   **단점**: 락을 더 오래 쥐고 있게 되므로, 다른 트랜잭션들이 해당 데이터를 사용하기 위해 기다리는 시간이 길어질 수 있다.

S2PL과 SS2PL은 복구 가능성을 보장하기 때문에 초창기 RDBMS에서 가장 많이 사용되는 구현 방식이었다.

### 7. 2PL의 한계와 새로운 발전: MVCC

2PL 방식은 리드락과 라이트락을 사용하는데, 리드-리드를 제외한 대부분의 락 호환성 문제(라이트-리드, 리드-라이트, 라이트-라이트)에서 한쪽 트랜잭션이 블락되기 때문에 **전체 처리량(Throughput)이 좋지 않다**는 문제가 있었다. 특히 쓰기 작업 중 읽기가 발생하거나 읽기 작업 중 쓰기가 발생하는 경우 블락이 일어나는 현상을 해결하고자 하는 노력이 계속되었다.

결과적으로 이러한 성능 문제를 해결하기 위한 방법으로 **MVCC(Multi-Version Concurrency Control, 멀티 버전 동시성 제어)**가 개발되었다. 오늘날 많은 RDBMS는 락과 MVCC를 혼용하여 사용하고 있다.
 
---
데이터베이스 동시성 제어는 트랜잭션의 일관성을 유지하는 데 필수적이며, 이를 위해 락이 사용된다. 특히 **2PL 프로토콜은 직렬성(Serializability)을 보장**하여 여러 트랜잭션이 동시에 실행되더라도 순차적인 실행과 동일한 결과를 얻을 수 있도록 한다. 또한 **S2PL이나 SS2PL과 같은 2PL의 변형은 복구 가능성(Recoverability)까지 보장**하여 데이터 무결성을 더욱 강화한다. 초창기 RDBMS에서 중요한 역할을 했지만, 성능 향상을 위해 MVCC와 같은 새로운 동시성 제어 방식이 도입되면서 락과 MVCC를 혼합한 형태로 발전해나가고 있다.