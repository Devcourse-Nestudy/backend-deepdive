관계형 데이터베이스 관리 시스템(RDBMS)에서 동시성 제어는 여러 트랜잭션이 동시에 데이터를 안전하고 효율적으로 처리하도록 돕는 핵심 기능이다. 기존의 락(Lock) 기반 방식은 읽기와 쓰기가 서로를 블락하여 동시 처리량을 저하시키는 한계가 있었고, 이 문제를 해결하기 위해 **MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)**가 개발되었다. 오늘날 대부분의 RDBMS는 MVCC를 사용하여 높은 동시성과 성능을 제공한다.

### 1. MVCC의 기본 개념과 동작 방식

MVCC는 여러 버전의 데이터를 유지함으로써 동시성 제어를 가능하게 하는 기법이다. 락 기반 방식이 같은 데이터에 대한 읽기-읽기만 허용하고 나머지는 블락하는 반면, MVCC는 **같은 데이터에 대해 쓰기-쓰기(Write-Write)가 발생할 때만 한쪽을 블락**하고, 그 외의 경우에는 블락 없이 동시 처리가 가능하다. 이로 인해 트랜잭션 처리량이 증가하여 전반적인 성능이 향상된다.

MVCC의 핵심 동작 원리는 다음과 같다.

- **데이터 쓰기**: 트랜잭션이 데이터를 변경(쓰기)할 때, RDBMS는 해당 데이터에 대한 **쓰기 락(Write Lock)**을 획득한다. 대부분의 RDBMS는 MVCC 구현 시에도 쓰기 락을 사용한다. 데이터는 즉시 데이터베이스에 반영되지 않고, **해당 트랜잭션만 알 수 있는 별도의 공간에 새로운 버전으로 기록된다**.
- **데이터 읽기**: MVCC의 가장 중요한 특징은 **커밋(Commit)된 데이터만 읽는다**는 점이다. 만약 어떤 트랜잭션이 아직 커밋되지 않은 데이터를 읽으려 한다면, MVCC는 데이터베이스에 이미 커밋되어 있는 이전 버전을 읽어온다.
- **커밋 시점**: 트랜잭션이 커밋되면, 해당 트랜잭션이 생성한 새로운 데이터 버전이 비로소 데이터베이스에 반영되고, 해당 데이터에 걸려 있던 쓰기 락은 해제된다. 락의 획득 및 해제는 개발자가 직접 수행하는 것이 아니라 RDBMS가 내부적으로 처리한다. 락은 트랜잭션 롤백 시 데이터 일관성을 보장하는 **복구 가능성(Recoverability)**을 위해 커밋 시점까지 유지된다.
- **버전 관리**: MVCC는 데이터의 변경 이력(History)을 내부적으로 관리해야 한다. 이는 **추가적인 저장 공간을 필요**로 한다는 단점이 될 수 있다. 하지만 읽기-쓰기, 쓰기-읽기 작업이 서로를 블락하지 않아 **성능 면에서 큰 장점**을 가진다. MySQL에서는 이렇게 특정 시점을 기준으로 커밋된 데이터를 읽는 방식을 **Consistent Read(일관된 읽기)**라고 부른다.

### 2. 격리 수준(Isolation Level)에 따른 MVCC 동작 방식

MVCC는 데이터를 읽을 때 **"특정 시점"을 기준으로 가장 최근에 커밋된 데이터를 읽는다**. 여기서 "특정 시점"은 트랜잭션의 **격리 수준**에 따라 달라진다.

#### 2.1 Read Committed (읽기 커밋)

- **동작 방식**: Read Committed 격리 수준에서 트랜잭션은 **데이터를 읽는 시점을 기준으로 그 전에 커밋된 데이터**를 읽는다.
- **예시 (MySQL 및 PostgreSQL 동일)**: 데이터베이스에 `x=10`이 있는 상황에서, 트랜잭션 2가 `x` 값을 50으로 변경하고 커밋한 후, 트랜잭션 1이 `x`를 읽으면 50을 읽는다. 왜냐하면 트랜잭션 1이 읽는 시점에 `x`의 최신 커밋 값은 50이기 때문이다.
- **로스트 업데이트(Lost Update) 발생 가능성**: Read Committed 격리 수준은 **로스트 업데이트(Lost Update)**와 같은 이상 현상을 방지하지 못할 수 있다.
  - **시나리오**: `x=50, y=10`인 상태에서, 트랜잭션 1은 `x`에서 `y`로 40을 이체하고, 트랜잭션 2는 `x`에 30을 입금하는 상황을 가정한다.
  - 트랜잭션 1이 먼저 시작하여 `x` 값을 50으로 읽고, `x`를 10으로 업데이트한다(아직 커밋되지 않아 트랜잭션 1만의 공간에 기록되며, `x`에 대한 쓰기 락을 보유).
  - 이때 트랜잭션 2가 시작하여 `x` 값을 50으로 읽는다(트랜잭션 1의 변경은 아직 커밋되지 않았으므로).
  - 트랜잭션 2는 `x`에 30을 더해 80으로 업데이트하려 시도하지만, 트랜잭션 1이 `x`에 대한 쓰기 락을 쥐고 있어 **블락되어 대기**한다.
  - 트랜잭션 1이 `y`를 50으로 업데이트하고 커밋하면, `x=10, y=50`이 데이터베이스에 반영되고 락이 해제된다.
  - 트랜잭션 2는 이제 `x`에 대한 쓰기 락을 획득하고, `x`를 80으로 업데이트한 후 커밋한다. 최종적으로 데이터베이스는 `x=80, y=50`이 된다.
  - **결과**: 최종 `x` 값은 80, `y` 값은 50으로, 예상 결과(`x=40, y=50`)와 다르다. 트랜잭션 1의 `x`에 대한 업데이트(`x=10`)가 트랜잭션 2에 의해 덮어씌워져 사라진 것이다.

#### 2.2 Repeatable Read (반복 가능 읽기)

- **동작 방식**: Repeatable Read 격리 수준에서 트랜잭션은 **트랜잭션 시작 시점을 기준으로 그 전에 커밋된 데이터**를 읽는다. (참고로, "트랜잭션 시작 시점" 기준은 RDBMS마다 다를 수 있으며, 최초의 읽기 시점이나 최초의 쓰기 포함 오퍼레이션 시점을 기준으로 할 수도 있다).
- **예시**: 트랜잭션 1이 시작할 때 `x` 값이 10이었다면, 트랜잭션 2가 `x`를 50으로 바꾸고 커밋하더라도, 트랜잭션 1이 나중에 `x`를 다시 읽으면 여전히 10을 읽게 된다. 이 동작 방식은 MySQL과 PostgreSQL 모두 동일하다.
- **로스트 업데이트 해결 (PostgreSQL vs. MySQL)**:
  - **PostgreSQL**: Repeatable Read 레벨에서는 같은 데이터에 대해 여러 트랜잭션이 업데이트를 시도할 때, **먼저 업데이트하고 커밋한 트랜잭션이 승리한다**. 이후에 업데이트를 시도하는 트랜잭션은 해당 쓰기가 **실패하고 롤백된다**. 이를 **"First Updater Wins"**라고 부른다. 이 방식 덕분에 앞선 로스트 업데이트 시나리오에서 트랜잭션 1이 커밋하면, 대기 중이던 트랜잭션 2는 롤백되어 트랜잭션 1의 결과(`x=10, y=50`)만 최종적으로 데이터베이스에 남게 되어 올바른 결과를 얻는다.
  - **MySQL**: PostgreSQL과는 달리, MySQL의 Repeatable Read는 "First Updater Wins" 개념이 없다. 따라서 앞서 Read Committed에서 보았던 로스트 업데이트 시나리오와 동일하게, 블락되었던 트랜잭션이 락을 획득한 후 정상적으로 쓰기를 진행하여 **여전히 로스트 업데이트가 발생**할 수 있다. 즉, MySQL의 Repeatable Read만으로는 해당 로스트 업데이트를 완전히 해결하지 못한다.

#### 2.3 Serializable (직렬화 가능)

- **동작 방식**: Serializable 격리 수준은 직렬 실행과 동일한 결과를 보장하여 가장 높은 수준의 격리를 제공한다.
- **MySQL**: 이 레벨에서는 MVCC로 동작하기보다는 **락(Lock) 기반으로 동작**하는 경향이 있다.
- **PostgreSQL**: **SSI(Serializable Snapshot Isolation) 기법이 적용된 MVCC**로 동작한다.

#### 2.4 Read Uncommitted (읽기 비커밋)

- **동작 방식**: MVCC는 기본적으로 **커밋된 데이터만을 읽기** 때문에, 일반적으로 Read Uncommitted 레벨에서는 MVCC가 적용되지 않는다.
- **MySQL**: MVCC는 주로 Read Committed와 Repeatable Read 레벨에서 적용된다고 알려져 있다.
- **PostgreSQL**: Read Uncommitted 레벨이 존재하지만, 실제로는 **Read Committed 레벨과 동일하게 동작**한다.

### 3. 트랜잭션 격리 수준 선택의 중요성

위에서 로스트 업데이트 시나리오를 통해 살펴보았듯이, 한 트랜잭션의 격리 수준만 높다고 해서 모든 이상 현상이 해결되는 것은 아니다. **관련된 다른 트랜잭션들의 격리 수준을 함께 고려**하여 적절히 설정해야 한다.

예를 들어, PostgreSQL 환경에서 트랜잭션 2가 먼저 시작하여 X에 30을 입금하고(Read Committed), 트랜잭션 1이 X에서 Y로 40을 이체하는(Read Committed) 상황에서, 트랜잭션 2가 먼저 X를 80으로 업데이트하고 커밋한 뒤, 블락되었던 트랜잭션 1이 X를 10으로 업데이트하고 커밋하면, 최종 결과는 `x=10, y=50`이 되어 트랜잭션 2의 X에 대한 업데이트가 유실되는 로스트 업데이트가 발생한다. 이때, 만약 트랜잭션 1의 격리 수준을 Repeatable Read로 높여준다면, PostgreSQL의 "First Updater Wins" 규칙에 따라 트랜잭션 1은 롤백되고 트랜잭션 2의 결과만 최종적으로 데이터베이스에 적용되어 (`x=80, y=10`) 로스트 업데이트를 해결할 수 있다.

MVCC는 락 기반 동시성 제어의 한계를 극복하고 데이터베이스의 동시성 및 성능을 크게 향상시킨 중요한 기술이다. 각 RDBMS와 격리 수준에 따라 MVCC의 동작 방식에 미묘한 차이가 있을 수 있으므로, 사용하려는 RDBMS의 매뉴얼을 확인하여 정확한 동작 방식을 이해하는 것이 중요한다. 이를 통해 데이터베이스 트랜잭션의 일관성과 무결성을 효과적으로 관리할 수 있다.
