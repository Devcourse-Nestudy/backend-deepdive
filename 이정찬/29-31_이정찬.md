B-트리는 이진 탐색 트리를 일반화한 형태의 자료 구조이다. 데이터베이스 인덱스에 주로 사용되는 트리임은 익히 알려진 사실이다. 이 트리는 고유한 특징과 효율적인 데이터 삽입 및 삭제 방식을 가지며, 특정 환경에서 뛰어난 성능을 발휘한다.

### B-트리의 개념, 특징 및 데이터 삽입 방식

B-트리를 이해하기 위해서는 먼저 **이진 탐색 트리(Binary Search Tree, BST)**에 대한 이해가 필요하다. 이진 탐색 트리는 모든 노드의 왼쪽 서브트리는 해당 노드의 값보다 작은 값들을, 오른쪽 서브트리는 큰 값들을 가지는 특징을 지닌다. 이진 탐색 트리는 최대 2개의 자녀 노드만을 가질 수 있다.

B-트리는 이러한 이진 탐색 트리의 개념을 확장하여 **자녀 노드의 최대 개수를 2개 이상으로 늘린 형태**이다. 이를 위해 **부모 노드에는 하나 이상의 키 값을 저장**하여, 이 키 값들을 기준으로 자녀 노드들이 가질 수 있는 값의 범위를 결정한다. 예를 들어, 부모 노드에 `K1`과 `K2` 두 개의 키가 오름차순으로 정렬되어 있다면:

- 왼쪽 자녀 노드는 `K1`보다 작은 값을 가진다.
- 가운데 자녀 노드는 `K1`보다 크고 `K2`보다 작은 값을 가진다.
- 오른쪽 자녀 노드는 `K2`보다 큰 값을 가진다.

이러한 방식으로 트리를 구성하며, 각 노드의 키들은 항상 **오름차순으로 정렬**되어 저장된다.

**B-트리의 주요 파라미터**는 다음과 같다:

- **m (차수)**: B-트리 각 노드가 가질 수 있는 **최대 자녀 노드 수**를 의미하며, 가장 중요하고 근본이 되는 파라미터이다. m차 B-트리라고 부른다.
- **각 노드의 최대 키 수**: `m - 1`로 결정된다. (예: 3차 B-트리인 경우 최대 2개의 키를 가진다).
- **각 노드의 최소 자녀 노드 수**: `ceil(m / 2)`로 결정된다. (단, 루트 노드나 리프 노드에는 적용되지 않는다). `ceil`은 올림을 의미한다.
- **각 노드의 최소 키 수**: `ceil(m / 2) - 1`로 결정된다. (단, 루트 노드에는 적용되지 않는다).

B-트리의 **핵심 특징** 중 하나는, 리프 노드를 제외한 모든 **인터널 노드(internal node)**는 **노드의 키 개수가 `x`개라면, 자녀 노드의 수는 항상 `x + 1`개여야 한다**는 것이다. 또한, B-트리는 **모든 리프 노드가 같은 레벨에 위치**한다는 특징을 가지며, 이는 B-트리가 **균형 잡힌 트리(balanced tree)**임을 의미한다. 이로 인해 탐색 시 시간 복잡도가 일정하게 유지되는 장점이 있다.

**B-트리에 데이터를 삽입하는 방식**은 다음과 같다:

1.  **데이터 추가는 항상 리프 노드에서 발생한다.** 삽입할 데이터를 저장할 적절한 리프 노드를 찾아야 한다.
2.  데이터가 추가될 때 **오름차순으로 정렬**되어 저장된다.
3.  데이터 추가 후, 노드가 **넘치면(overflow)** 즉, 최대 키 수(`m-1`)를 초과하면 재조정이 발생한다.
4.  노드가 넘치면 **가운데 키 값(중앙값 또는 메디안)**을 기준으로 좌우 키들을 **분할**한다.
5.  분할된 노드의 **가운데 키 값은 상위 레벨의 부모 노드로 승진(promote)한다.**.
6.  승진된 키가 부모 노드에서도 오버플로우를 발생시키면, 이 과정은 루트 노드에 도달할 때까지 **반복적으로 상위 레벨로 전파될 수 있다**. 만약 루트 노드가 오버플로우되면 새로운 루트 노드가 생성되고 트리의 높이가 증가한다.

### B-트리의 데이터 삭제 방식

B-트리의 **데이터 삭제 방식**은 삽입 방식과 마찬가지로 특정 규칙에 따라 트리 구조의 균형을 유지한다.

1.  **데이터 삭제는 항상 리프 노드에서 발생한다.**
2.  만약 **삭제하려는 데이터가 인터널 노드에 있는 경우**, 해당 데이터의 **선임자(predecessor) 또는 후임자(successor)**와 위치를 바꾼다. 선임자는 해당 데이터보다 작은 값들 중 가장 큰 값이고, 후임자는 해당 데이터보다 큰 값들 중 가장 작은 값을 의미한다. 이 선임자나 후임자는 항상 리프 노드에 존재한다. 위치를 바꾼 후, 이제 삭제하려는 데이터는 리프 노드에 있게 되므로 리프 노드에서 삭제를 진행한다.
3.  데이터 삭제 후, 해당 노드의 키 수가 **최소 키 수(`ceil(m/2)-1`)보다 적어지면** 트리를 **재조정(rebalance)**해야 한다. 재조정 과정은 크게 두 가지로 나뉜다:
    - **형제로부터 키 빌리기**: 삭제로 인해 키가 부족해진 노드의 **좌우 형제 노드**를 확인하여 여유 키가 있는지 파악한다.
      - 여유 키가 있는 형제가 있다면, **부모 노드에 있는 키를 내려받고, 형제의 여유 키 중 하나를 부모 노드로 올린다.** 이 과정에서 B-트리의 정렬 특성이 유지된다.
    - **부모의 지원을 받아 형제와 합치기**: 만약 좌우 형제 모두 여유 키가 없어 빌릴 수 없는 상황이라면, **부모 노드의 지원을 받아 형제 노드와 합쳐진다(merge).**
      - 합쳐질 때는 부모 노드에 있는 키 하나가 부족한 노드와 형제 노드 사이로 내려오고, 부족한 노드와 형제 노드의 키들이 합쳐져 하나의 노드가 된다. (일반적으로 왼쪽으로 합쳐진다).
      - 이 과정에서 부모 노드의 키 수가 최소 조건을 위반할 수 있으며, 이 경우 **부모 노드도 다시 재조정 과정(형제로부터 빌리거나 합치기)을 시작한다.**.
      - 만약 루트 노드가 키를 지원해주고 비어 있게 되면, 루트 노드는 삭제되고 직전에 합쳐진 노드가 새로운 루트 노드가 된다.

### B-트리가 DB 인덱스로 사용되는 이유

B-트리 계열(B-tree, B+tree, B\*tree 등)이 데이터베이스 인덱스로 사용되는 주된 이유는 **컴퓨터 시스템의 메모리 계층 구조와 보조 기억 장치(Secondary Storage)의 특성**에 효율적으로 대응할 수 있기 때문이다.

**시간 복잡도**: B-트리 계열은 데이터 조회, 삽입, 삭제에 대해 평균 케이스와 최악 케이스 모두 **O(log n)의 시간 복잡도를 가진다.**. 이는 스스로 균형을 잡는 이진 탐색 트리(AVL 트리, 레드-블랙 트리)와 동일한 시간 복잡도이다. 그러나 단순한 시간 복잡도만으로는 B-트리가 DB 인덱스로 더 적합한 이유를 설명하기 어렵다.

**컴퓨터 시스템의 메모리 계층**:

- **CPU**: 프로그램 코드가 실제로 실행되는 곳이다.
- **메인 메모리(RAM)**: 실행 중인 프로그램 코드와 데이터가 임시로 상주하는 곳으로, 휘발성 메모리이다.
- **보조 기억 장치(Secondary Storage)**: 프로그램과 데이터가 영구적으로 저장되는 곳(비휘발성 메모리)으로, HDD나 SSD 등이 있다. 데이터베이스는 기본적으로 이곳에 저장된다.

**보조 기억 장치의 특징**:

1.  **느린 데이터 처리 속도**: 메인 메모리(RAM)에 비해 HDD나 SSD는 데이터 처리 속도가 현저히 느리다. (RAM: 초당 40-50GB, SSD: 초당 3-5GB, HDD: 초당 0.2-0.3GB).
2.  **큰 저장 용량**: 메인 메모리에 비해 훨씬 큰 용량의 데이터를 저장할 수 있다.
3.  **블록 단위 입출력**: 데이터를 읽거나 쓸 때 **블록(Block) 단위**로 읽고 쓴다. 블록은 파일 시스템이 데이터를 읽고 쓰는 논리적인 단위를 의미하며, 보통 4KB, 8KB 등으로 표현된다. 특정 데이터를 읽어올 때 해당 데이터를 포함하는 블록 전체를 메인 메모리로 가져와야 한다.

**B-트리가 DB 인덱스로 사용되는 이유**:
데이터베이스 시스템은 성능 최적화를 위해 **보조 기억 장치에 대한 접근 횟수를 최소화**하는 것이 매우 중요하다. B-트리는 이러한 보조 기억 장치의 특성을 고려하여 설계되었다.

1.  **트리의 높이 단축**: B-트리는 각 노드에 여러 개의 키를 저장할 수 있으므로, 동일한 수의 데이터를 저장하더라도 이진 탐색 트리에 비해 **트리의 높이가 훨씬 짧아진다.**. 이는 루트 노드에서 리프 노드(데이터를 찾는 최종 지점)까지 도달하기 위한 **디스크 I/O 횟수를 줄여** 검색 성능을 향상시킨다. (예: 5차 B-트리로 5를 검색했을 때 2번의 디스크 접근이 발생한 반면, AVL 트리에서는 4번의 접근이 필요했다).
2.  **블록 공간 활용도 극대화**: B-트리 노드는 여러 키를 저장하며, 이는 보조 기억 장치의 **블록 단위 입출력 특성**을 효과적으로 활용한다. 한 번의 블록 읽기로 더 많은 관련 키(데이터)들을 메인 메모리로 가져올 수 있어, 블록 내의 공간 활용도가 높고, 이는 **공간 지역성(Spatial Locality)**을 높여 성능 이점으로 작용한다.
3.  **대용량 데이터 처리 능력**: 예를 들어 101차 B-트리의 경우, 단 3단계의 높이만으로 약 1억 개의 데이터를 저장할 수 있다 (베스트 케이스). 최악의 경우에도 26만 개 이상의 데이터를 저장하며, 평균적으로 수백만에서 수천만 개의 데이터를 단 몇 번의 디스크 접근(예: 4개의 레벨로 3번의 이동)만으로 처리할 수 있는 강력함을 가진다. 이러한 대용량 처리 능력은 데이터베이스 인덱스로서 B-트리를 매우 적합한 자료 구조로 만든다.

결론적으로, B-트리 계열은 **보조 기억 장치 접근 횟수를 최소화**하는 것이 핵심인 데이터베이스 환경에서 효율적인 검색, 삽입, 삭제를 가능하게 하는 최적의 자료 구조로 평가된다. 해시 인덱스도 존재하지만, 정렬이나 범위 기반 검색이 불가능하다는 단점이 있어 일반적으로는 B-트리 기반 인덱스가 더 많이 사용된다.
